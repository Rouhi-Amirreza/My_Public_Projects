import React, { useState, useEffect, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  Image,
  Dimensions,
  Platform,
  Animated,
  Modal,
  TextInput,
  Alert,
  ActivityIndicator,
} from 'react-native';
import { getMapView, getMarker, getPolyline } from '../components/MapComponents';
import { GeneratedItinerary, PlaceRecommendation, MultiDayItinerary, DailyItinerary, ItineraryFormData, DiningStop, BookingInfo, TicketBooking, RideBooking, TravelOptions } from '../types';
import { PHILADELPHIA_CENTER, Colors } from '../utils/constants';
import DataService from '../services/DataService';
import DiningStopSelector from '../components/DiningStopSelector';
import DiningStopEditor from '../components/DiningStopEditor';
import PlaceImage from '../components/PlaceImage';
import PlaceChangeSelector from '../components/PlaceChangeSelector';
import GooglePlacesImageService from '../services/GooglePlacesImageService';
import { DiningOption } from '../services/DiningService';
import DiningService from '../services/DiningService';
import UnifiedTravelCalculator from '../services/UnifiedTravelCalculator';
import TravelTimeDisplayService from '../services/TravelTimeDisplayService';
import GoogleMapsService from '../services/GoogleMapsService';
import ItineraryService from '../services/ItineraryService';
import TicketBookingCard from '../components/TicketBookingCard';
import RideBookingCard from '../components/RideBookingCard';
import RideSelectionModal from '../components/RideSelectionModal';
import TravelIndicator from '../components/TravelIndicator';
import DualTravelIndicator from '../components/DualTravelIndicator';
import CheckoutPage from './CheckoutPage';
import PrintItinerary from '../components/PrintItinerary';
import BookingConfirmationPage from './BookingConfirmationPage';
import ReservationModal from '../components/ReservationModal';
import DebugLogger from '../services/DebugLogger';
import OptimizationNotesPanel from '../components/OptimizationNotesPanel';
import BookingSection from '../components/BookingSection';
import DebugPanel from '../components/DebugPanel';
import ItineraryMap from '../components/ItineraryMap';
import DayTabs from '../components/DayTabs';
import PlaceCard from '../components/PlaceCard';

const { width, height } = Dimensions.get('window');

interface ItineraryResultsPageProps {
  itinerary: GeneratedItinerary | MultiDayItinerary;
  startingLocation: {
    address: string;
    coordinates: {
      latitude: number;
      longitude: number;
    };
  };
  returnLocation?: {
    address: string;
    coordinates: {
      latitude: number;
      longitude: number;
    };
  };
  formData: ItineraryFormData;
  onBackToForm: () => void;
  onRegenerateItinerary: () => void;
}

const ItineraryResultsPage: React.FC<ItineraryResultsPageProps> = ({
  itinerary,
  startingLocation,
  returnLocation,
  formData,
  onBackToForm,
  onRegenerateItinerary,
}) => {
  // Initialize map components using singleton pattern
  const MapView = getMapView();
  const Marker = getMarker();
  const Polyline = getPolyline();
  const [expandedHours, setExpandedHours] = useState<Set<string>>(new Set());
  const [activeDay, setActiveDay] = useState<number>(1);
  const [diningModalVisible, setDiningModalVisible] = useState(false);
  const [selectedRouteSegment, setSelectedRouteSegment] = useState<{
    fromIndex: number;
    toIndex: number;
    fromLocation: { name: string; coordinates: { lat: number; lng: number } };
    toLocation: { name: string; coordinates: { lat: number; lng: number } };
    arrivalTime: string;
  } | null>(null);
  const [itineraryState, setItineraryState] = useState(itinerary);
  const [editingDiningStop, setEditingDiningStop] = useState<{
    stop: DiningStop;
    itemIndex: number;
    stopIndex: number;
  } | null>(null);
  
  // State for visit duration editing
  const [editingVisitDuration, setEditingVisitDuration] = useState<{
    scheduleIndex: number;
    currentDuration: number;
    placeName: string;
  } | null>(null);
  const [newVisitDuration, setNewVisitDuration] = useState<string>('');
  
  // Booking state
  const [showCheckout, setShowCheckout] = useState(false);
  const [showPrintItinerary, setShowPrintItinerary] = useState(false);
  const [showConfirmation, setShowConfirmation] = useState(false);
  const [showReservationModal, setShowReservationModal] = useState(false);
  const [selectedDiningStop, setSelectedDiningStop] = useState<DiningStop | null>(null);
  const [showDebugPanel, setShowDebugPanel] = useState(false);
  
  // Auto-start debug logging on component mount
  React.useEffect(() => {
    DebugLogger.start();
    setIsDebugLogging(true);
    console.log('üîç Auto-started debug logging for schedule calculations');
    
    // Cleanup on unmount
    return () => {
      DebugLogger.stop();
    };
  }, []);
  const [ticketBookings, setTicketBookings] = useState<TicketBooking[]>([]);
  const [rideBookings, setRideBookings] = useState<RideBooking[]>([]);
  const [showRideModal, setShowRideModal] = useState(false);
  
  // Toggle states for select all functionality
  const [allTicketsSelected, setAllTicketsSelected] = useState(false);
  const [allRidesSelected, setAllRidesSelected] = useState(false);
  
  // Travel mode state management - maps rideId to selected travel mode
  const [travelModes, setTravelModes] = useState<Record<string, 'driving' | 'walking'>>({});
  // Store calculated travel options for each segment
  const [travelOptions, setTravelOptions] = useState<Record<string, TravelOptions>>({});
  
  // Add flag to prevent infinite recalculations
  const [isRecalculating, setIsRecalculating] = useState(false);
  
  // Removed broken calculateApproximateDistance function - now using GoogleMapsService fallbacks
  const [isDebugLogging, setIsDebugLogging] = useState(false);
  const [debugLogContent, setDebugLogContent] = useState<string>('');
  const [summaryExpanded, setSummaryExpanded] = useState(false);
  const [summaryHeight] = useState(new Animated.Value(0));
  const [summaryRotation] = useState(new Animated.Value(0));
  const [selectedRideSegment, setSelectedRideSegment] = useState<{
    fromLocation: string;
    toLocation: string;
    fromCoordinates: { latitude: number; longitude: number };
    toCoordinates: { latitude: number; longitude: number };
    distance: number;
    estimatedDuration: number;
    rideId: string;
    scheduledTime?: string;
  } | null>(null);
  
  // Calculate booking totals with safety checks to prevent NaN values
  const bookingInfo: BookingInfo = {
    ticketBookings,
    rideBookings,
    totalTicketCost: ticketBookings.reduce((sum, ticket) => {
      const safePrice = isNaN(ticket.totalPrice) ? 0 : ticket.totalPrice;
      return sum + safePrice;
    }, 0),
    totalRideCost: rideBookings.reduce((sum, ride) => {
      const safePrice = isNaN(ride.estimatedPrice) ? 0 : ride.estimatedPrice;
      return sum + safePrice;
    }, 0),
    totalCost: ticketBookings.reduce((sum, ticket) => {
      const safePrice = isNaN(ticket.totalPrice) ? 0 : ticket.totalPrice;
      return sum + safePrice;
    }, 0) + 
    rideBookings.reduce((sum, ride) => {
      const safePrice = isNaN(ride.estimatedPrice) ? 0 : ride.estimatedPrice;
      return sum + safePrice;
    }, 0),
  };

  // Toggle all tickets functionality
  const handleToggleAllTickets = () => {
    if (!currentItinerary || !currentItinerary.places) return;
    
    if (allTicketsSelected) {
      // Deselect all tickets
      setTicketBookings([]);
      setAllTicketsSelected(false);
    } else {
      // Select all available tickets
      const allTickets: TicketBooking[] = [];
      currentItinerary.places.forEach((place, index) => {
        if (place.ticket_info && place.ticket_info.length > 0) {
          const ticketInfo = place.ticket_info[0];
          // CRITICAL FIX: Use robust price parsing to avoid NaN values
          const price = parseFloat(ticketInfo.price.replace(/[^0-9.]/g, '')) || 0;
          
          // Debug logging to identify problematic tickets
          console.log(`üé´ Ticket parsing for ${place.name}:`, {
            originalPrice: ticketInfo.price,
            parsedPrice: price,
            isOfficial: ticketInfo.is_official,
            hasValidPrice: !isNaN(price) && price > 0
          });
          
          // Only add tickets with valid prices
          if (!isNaN(price) && price > 0) {
            allTickets.push({
              placeId: place.place_id,
              placeName: place.name,
              ticketType: ticketInfo.is_official ? 'Official' : 'Third Party',
              price: price,
              quantity: 1,
              totalPrice: price,
              bookingLink: ticketInfo.link,
              isOfficial: ticketInfo.is_official,
              day: isMultiDay(itinerary) ? activeDay : undefined,
              arrivalTime: currentItinerary.schedule[index]?.arrivalTime,
            });
          } else {
            console.warn(`‚ö†Ô∏è Skipping ticket for ${place.name} - invalid price: ${ticketInfo.price} -> ${price}`);
          }
        }
      });
      setTicketBookings(allTickets);
      setAllTicketsSelected(true);
    }
  };

    // Helper function to collect all visible ride IDs in the UI (matching toggle function conditions)
  const getAllVisibleRideIds = () => {
    const visibleRideIds: string[] = [];
    
    // Start to first place - only if driving mode
    if (currentItinerary.places.length > 0) {
      const firstPlace = currentItinerary.places[0];
      const startRideId = generateRideId('start', firstPlace.name, 0);
      const startTravelMode = travelModes[startRideId] || 'driving';
      if (startTravelMode === 'driving') {
        visibleRideIds.push(startRideId);
      }
    }
    
    // Between places - only if driving mode
    for (let i = 1; i < currentItinerary.places.length; i++) {
      const fromPlace = currentItinerary.places[i - 1];
      const toPlace = currentItinerary.places[i];
      const rideId = generateRideId(fromPlace.name, toPlace.name, i);
      const travelMode = travelModes[rideId] || 'driving';
      if (travelMode === 'driving') {
        visibleRideIds.push(rideId);
      }
    }
    
    // Return ride - only if driving mode
    if (currentItinerary.places.length > 0) {
      const lastPlace = currentItinerary.places[currentItinerary.places.length - 1];
      const returnRideId = generateRideId(lastPlace.name, 'return', 999);
      const returnTravelMode = travelModes[returnRideId] || 'driving';
      if (returnTravelMode === 'driving') {
        visibleRideIds.push(returnRideId);
      }
    }
    
    // Dining stops (only include bookable rides with driving mode)
    currentItinerary.places.forEach((place, index) => {
      // After-place dining stops (rendered at schedule[index + 1])
      if (currentItinerary.schedule[index + 1]?.diningStops) {
        currentItinerary.schedule[index + 1].diningStops.forEach((diningStop: any, diningIndex: number) => {
          // Ride TO dining stop (only if bookable and driving mode)
          const toDrivingTime = diningStop.travel_breakdown?.travel_to_restaurant || 0;
          const canBookToRide = toDrivingTime >= 1;
          if (canBookToRide) {
            const toRideId = generateRideId(place.name, diningStop.name, `${index}_${diningIndex}_to`);
            const toTravelMode = travelModes[toRideId] || (diningStop.travel_breakdown?.travel_to_mode === 'walking' ? 'walking' : 'driving');
            if (toTravelMode === 'driving') {
              visibleRideIds.push(toRideId);
            }
          }
          // Ride FROM dining stop (only if bookable and driving mode)
          const fromDrivingTime = diningStop.travel_breakdown?.travel_from_restaurant || 0;
          const canBookFromRide = fromDrivingTime >= 1;
          if (canBookFromRide) {
            const nextPlace = index + 1 < currentItinerary.places.length ? currentItinerary.places[index + 1] : null;
            const fromRideId = generateRideId(diningStop.name, nextPlace ? nextPlace.name : 'return', `${index}_${diningIndex}_from`);
            const fromTravelMode = travelModes[fromRideId] || (diningStop.travel_breakdown?.travel_from_mode === 'walking' ? 'walking' : 'driving');
            if (fromTravelMode === 'driving') {
              visibleRideIds.push(fromRideId);
            }
          }
        });
      }
    });
    
    // Pre-first dining stops (only if driving mode)
    if (currentItinerary.schedule[0]?.diningStops) {
      currentItinerary.schedule[0].diningStops.forEach((diningStop: any, diningIndex: number) => {
        const toRideId = generateRideId('start', diningStop.name, 'pre_first_dining_to');
        const toTravelMode = travelModes[toRideId] || 'driving';
        if (toTravelMode === 'driving') {
          visibleRideIds.push(toRideId);
        }
        
        const fromRideId = generateRideId(diningStop.name, currentItinerary.places[0].name, 'first_dining_from');
        const fromTravelMode = travelModes[fromRideId] || 'driving';
        if (fromTravelMode === 'driving') {
          visibleRideIds.push(fromRideId);
        }
      });
    }
    
    return visibleRideIds;
  };

  // Toggle all rides functionality
  const handleToggleAllRides = () => {
    if (!currentItinerary || !currentItinerary.places || !startingLocation) return;
    
    if (allRidesSelected) {
      // Deselect all rides
      setRideBookings([]);
      setAllRidesSelected(false);
    } else {
      // DEBUG: Log current itinerary structure
      console.log('üîç DEBUGGING ALL RIDES TOGGLE');
      console.log('Current itinerary:', currentItinerary);
      console.log('Current schedule:', currentItinerary.schedule);
      console.log('Current ride bookings:', rideBookings);
      // Get all visible ride IDs
      const visibleRideIds = getAllVisibleRideIds();
      console.log('üîç All visible ride IDs in UI:', visibleRideIds);
      console.log('üîç Currently booked ride IDs:', rideBookings.map(r => r.id));
      // Select all available rides
      const allRides: RideBooking[] = [];
      // DEBUG: Check each place for dining stops
      currentItinerary.places.forEach((place, index) => {
        console.log(`üîç Place ${index} (${place.name}):`, {
          scheduleItem: currentItinerary.schedule[index],
          hasDiningStops: !!(currentItinerary.schedule[index]?.diningStops),
          diningStopsCount: currentItinerary.schedule[index]?.diningStops?.length || 0
        });
      });
            // Add ride from start to first place (only if driving mode)
      if (currentItinerary.places.length > 0) {
        const firstPlace = currentItinerary.places[0];
        const startRideId = generateRideId('start', firstPlace.name, 0);
        const startTravelMode = travelModes[startRideId] || 'driving';
        if (startTravelMode === 'driving') {
          const startDisplayInfo = getTravelDisplayInfo(startRideId, 'driving');
          allRides.push({
            id: startRideId,
            fromLocation: startingLocation.address,
            toLocation: firstPlace.address,
            fromCoordinates: startingLocation.coordinates,
            toCoordinates: firstPlace.coordinates,
            rideType: 'uber' as const,
            estimatedPrice: 15.00,
            estimatedDuration: startDisplayInfo.duration || 15,
            distance: startDisplayInfo.distance || 1000,
            scheduledTime: currentItinerary.schedule?.[0]?.arrivalTime,
            selected: true,
          });
        }
      }
            // Add rides between places (only if driving mode)
      for (let i = 1; i < currentItinerary.places.length; i++) {
        const fromPlace = currentItinerary.places[i - 1];
        const toPlace = currentItinerary.places[i];
        const rideId = generateRideId(fromPlace.name, toPlace.name, i);
        const travelMode = travelModes[rideId] || 'driving';
        if (travelMode === 'driving') {
          const displayInfo = getTravelDisplayInfo(rideId, 'driving');
          allRides.push({
            id: rideId,
            fromLocation: fromPlace.address,
            toLocation: toPlace.address,
            fromCoordinates: fromPlace.coordinates,
            toCoordinates: toPlace.coordinates,
            rideType: 'uber' as const,
            estimatedPrice: 15.00,
            estimatedDuration: displayInfo.duration || 15,
            distance: displayInfo.distance || 1000,
            scheduledTime: currentItinerary.schedule?.[i]?.arrivalTime,
            selected: true,
          });
        }
      }
      // --- FIX: Use index+1 for after-place dining stops to match rendering logic ---
      currentItinerary.places.forEach((place, index) => {
        if (currentItinerary.schedule[index + 1]?.diningStops && currentItinerary.schedule[index + 1].diningStops.length > 0) {
          currentItinerary.schedule[index + 1].diningStops.forEach((diningStop: any, diningIndex: number) => {
            // Ride TO dining stop (only if bookable - match UI logic)
            const toDrivingTime = diningStop.travel_breakdown?.travel_to_restaurant || 0;
            const canBookToRide = toDrivingTime >= 1;
            if (canBookToRide) {
              const toRideId = generateRideId(place.name, diningStop.name, `${index}_${diningIndex}_to`);
                const toDisplayInfo = getTravelDisplayInfo(toRideId, 'driving');
                const toRide = {
                  id: toRideId,
                  fromLocation: place.address,
                  toLocation: diningStop.address,
                  fromCoordinates: place.coordinates,
                  toCoordinates: diningStop.coordinates,
                  rideType: 'uber' as const,
                  estimatedPrice: 15.00,
                  estimatedDuration: toDisplayInfo.duration || 15,
                  distance: toDisplayInfo.distance || 1000,
                  scheduledTime: diningStop.arrival_time,
                  selected: true,
                };
                allRides.push(toRide);
              console.log(`üçΩÔ∏è Added TO ride: ${toRideId} (drive time: ${toDrivingTime}min)`);
            } else {
              console.log(`üçΩÔ∏è Skipped TO ride: ${place.name} ‚Üí ${diningStop.name} (drive time: ${toDrivingTime}min < 1min)`);
            }
                        // Ride FROM dining stop (only if bookable and driving mode)
            const fromDrivingTime = diningStop.travel_breakdown?.travel_from_restaurant || 0;
            const canBookFromRide = fromDrivingTime >= 1;
            if (canBookFromRide) {
              const nextPlace = index + 1 < currentItinerary.places.length ? currentItinerary.places[index + 1] : null;
              const fromRideId = generateRideId(diningStop.name, nextPlace ? nextPlace.name : 'return', `${index}_${diningIndex}_from`);
              const fromTravelMode = travelModes[fromRideId] || (diningStop.travel_breakdown?.travel_from_mode === 'walking' ? 'walking' : 'driving');
              if (fromTravelMode === 'driving') {
                const fromDisplayInfo = getTravelDisplayInfo(fromRideId, 'driving');
                const fromRide = {
                  id: fromRideId,
                  fromLocation: diningStop.address,
                  toLocation: nextPlace ? nextPlace.address : (returnLocation || startingLocation).address,
                  fromCoordinates: diningStop.coordinates,
                  toCoordinates: nextPlace ? nextPlace.coordinates : (returnLocation || startingLocation).coordinates,
                  rideType: 'uber' as const,
                  estimatedPrice: 15.00,
                  estimatedDuration: fromDisplayInfo.duration || 15,
                  distance: fromDisplayInfo.distance || 1000,
                  scheduledTime: diningStop.departure_time,
                  selected: true,
                };
                allRides.push(fromRide);
                console.log(`üçΩÔ∏è Added FROM ride: ${fromRideId} (drive time: ${fromDrivingTime}min, mode: driving)`);
              } else {
                console.log(`üçΩÔ∏è Skipped FROM ride: ${diningStop.name} ‚Üí ${nextPlace ? nextPlace.name : 'return'} (mode: ${fromTravelMode}, not driving)`);
              }
            } else {
              console.log(`üçΩÔ∏è Skipped FROM ride: ${diningStop.name} ‚Üí ${nextPlace ? nextPlace.name : 'return'} (drive time: ${fromDrivingTime}min < 1min)`);
            }
          });
        }
      });
      // Add pre-first dining stops (dining stops before first place)
      if (currentItinerary.schedule[0]?.diningStops && currentItinerary.schedule[0].diningStops.length > 0) {
        currentItinerary.schedule[0].diningStops.forEach((diningStop: any, diningIndex: number) => {
          // Ride TO pre-first dining stop
          const toRideId = generateRideId('start', diningStop.name, 'pre_first_dining_to');
            const toDisplayInfo = getTravelDisplayInfo(toRideId, 'driving');
            allRides.push({
              id: toRideId,
              fromLocation: startingLocation.address,
              toLocation: diningStop.address,
              fromCoordinates: startingLocation.coordinates,
              toCoordinates: diningStop.coordinates,
              rideType: 'uber' as const,
              estimatedPrice: 15.00,
              estimatedDuration: toDisplayInfo.duration || 15,
              distance: toDisplayInfo.distance || 1000,
              scheduledTime: diningStop.arrival_time,
              selected: true,
            });
          // Ride FROM pre-first dining stop to first place
          const fromRideId = generateRideId(diningStop.name, currentItinerary.places[0].name, 'first_dining_from');
            const fromDisplayInfo = getTravelDisplayInfo(fromRideId, 'driving');
            allRides.push({
              id: fromRideId,
              fromLocation: diningStop.address,
              toLocation: currentItinerary.places[0].address,
              fromCoordinates: diningStop.coordinates,
              toCoordinates: currentItinerary.places[0].coordinates,
              rideType: 'uber' as const,
              estimatedPrice: 15.00,
              estimatedDuration: fromDisplayInfo.duration || 15,
              distance: fromDisplayInfo.distance || 1000,
              scheduledTime: diningStop.departure_time,
              selected: true,
            });
        });
      }
      // Add return ride from last place back to starting/return location (using correct ID pattern)
      if (currentItinerary.places.length > 0) {
        const lastPlace = currentItinerary.places[currentItinerary.places.length - 1];
        const finalDestination = returnLocation || startingLocation;
        const returnRideId = generateRideId(lastPlace.name, 'return', 999); // Using correct ID pattern
          const returnDisplayInfo = getTravelDisplayInfo(returnRideId, 'driving');
          allRides.push({
            id: returnRideId,
            fromLocation: lastPlace.address,
            toLocation: finalDestination.address,
            fromCoordinates: lastPlace.coordinates,
            toCoordinates: finalDestination.coordinates,
            rideType: 'uber' as const,
            estimatedPrice: 15.00,
            estimatedDuration: returnDisplayInfo.duration || 15,
            distance: returnDisplayInfo.distance || 1000,
            scheduledTime: currentItinerary.schedule?.[currentItinerary.schedule.length - 1]?.departureTime,
            selected: true,
          });
        }
      console.log(`üöó Total rides added: ${allRides.length}`);
      console.log(`üöó All ride IDs:`, allRides.map(r => r.id));
      // Force update by ensuring it's a new array
      setRideBookings([...allRides]);
      setAllRidesSelected(true);
      // Debug: Check if state was updated
      setTimeout(() => {
        console.log('üîç State after toggle:', {
          rideBookingsLength: rideBookings.length,
          allRidesSelected
        });
      }, 100);
    }
  };

  // Square cards modal states
  const [activeModal, setActiveModal] = useState<'optimization' | 'missed' | 'popular' | 'dining' | null>(null);

  // Update toggle states when bookings change
  useEffect(() => {
    if (!currentItinerary || !currentItinerary.places) return;
    
    const availableTickets = currentItinerary.places.filter(place => 
      place.ticket_info && place.ticket_info.length > 0
    );
    setAllTicketsSelected(availableTickets.length > 0 && ticketBookings.length === availableTickets.length);
  }, [ticketBookings, currentItinerary]);

  useEffect(() => {
    if (!currentItinerary || !currentItinerary.places) return;
    
    const visibleRideIds = getAllVisibleRideIds();
    const totalAvailableRides = visibleRideIds.length;
    const isAllSelected = totalAvailableRides > 0 && rideBookings.length === totalAvailableRides;
    
    // DEBUG: Log ride selection status
    console.log('üîç Ride selection status:', {
      totalAvailableRides,
      currentBookedRides: rideBookings.length,
      visibleRideIds,
      bookedRideIds: rideBookings.map(r => r.id),
      isAllSelected,
      missingRides: visibleRideIds.filter(id => !rideBookings.some(r => r.id === id)),
      extraRides: rideBookings.filter(r => !visibleRideIds.includes(r.id)).map(r => r.id)
    });
    
    setAllRidesSelected(isAllSelected);
  }, [rideBookings, currentItinerary]);

  // Place changing state
  const [changingPlace, setChangingPlace] = useState<{
    place: PlaceRecommendation;
    index: number;
    alternatives: any[];
    visitTime: string;
    visitDate?: Date;
  } | null>(null);
  const [loadingAlternatives, setLoadingAlternatives] = useState(false);

  // Initialize map region with a basic region - will be updated in useEffect
  const [mapRegion, setMapRegion] = useState(() => {
    const currentCity = DataService.getCurrentCity();
    const cityCenter = currentCity?.coordinates || PHILADELPHIA_CENTER;
    return {
      latitude: cityCenter.latitude,
      longitude: cityCenter.longitude,
      latitudeDelta: 0.1,
      longitudeDelta: 0.1,
    };
  });

  // Map ref for controlling zoom
  const mapRef = useRef(null);

  // Zoom functions
  const zoomIn = () => {
    if (mapRef.current) {
      const currentRegion = mapRegion;
      const newRegion = {
        ...currentRegion,
        latitudeDelta: currentRegion.latitudeDelta * 0.5,
        longitudeDelta: currentRegion.longitudeDelta * 0.5,
      };
      mapRef.current.animateToRegion(newRegion, 300);
      setMapRegion(newRegion);
    }
  };

  const zoomOut = () => {
    if (mapRef.current) {
      const currentRegion = mapRegion;
      const newRegion = {
        ...currentRegion,
        latitudeDelta: currentRegion.latitudeDelta * 2,
        longitudeDelta: currentRegion.longitudeDelta * 2,
      };
      mapRef.current.animateToRegion(newRegion, 300);
      setMapRegion(newRegion);
    }
  };

  // Initialize image service and preload place photos
  useEffect(() => {
    const initializeAndPreload = async () => {
      try {
        await GooglePlacesImageService.initialize();
        
        // Preload photos for current itinerary places
        // Using memoized currentItinerary
        if (currentItinerary.places && currentItinerary.places.length > 0) {
          await GooglePlacesImageService.preloadPlacePhotos(
            currentItinerary.places.map(place => ({
              place_id: place.place_id,
              name: place.name
            }))
          );
        }
      } catch (error) {
        console.error('Failed to initialize place images:', error);
      }
    };

    initializeAndPreload();
  }, [itinerary]);

  // Type guard to check if it's a multi-day itinerary
  const isMultiDay = (checkItinerary: GeneratedItinerary | MultiDayItinerary): checkItinerary is MultiDayItinerary => {
    return 'dailyItineraries' in checkItinerary;
  };

  // Helper function to extract coordinates safely from different place formats
  const extractCoordinates = async (place: any): Promise<{ lat: number; lng: number }> => {
    console.log(`üîç Extracting coordinates for ${place.name}:`, {
      coordinates: place.coordinates,
      basic_info: place.basic_info,
      latitude: place.latitude,
      longitude: place.longitude,
      lat: place.lat,
      lng: place.lng
    });
    
    // Handle multiple coordinate formats that might exist after place replacement
    if (place.coordinates?.latitude && place.coordinates?.longitude) {
      const result = {
        lat: parseFloat(place.coordinates.latitude),
        lng: parseFloat(place.coordinates.longitude),
      };
      console.log('‚úÖ Using coordinates.latitude/longitude for', place.name, ':', result);
      return result;
    }
    if (place.coordinates?.lat && place.coordinates?.lng) {
      const result = {
        lat: parseFloat(place.coordinates.lat),
        lng: parseFloat(place.coordinates.lng),
      };
      console.log('‚úÖ Coordinates found for', place.name, ':', result);
      return result;
    }
    if (place.basic_info?.latitude && place.basic_info?.longitude) {
      const result = {
        lat: parseFloat(place.basic_info.latitude),
        lng: parseFloat(place.basic_info.longitude),
      };
      console.log('‚úÖ Coordinates found for', place.name, ':', result);
      return result;
    }
    if (place.latitude && place.longitude) {
      const result = {
        lat: parseFloat(place.latitude),
        lng: parseFloat(place.longitude),
      };
      console.log('‚úÖ Coordinates found for', place.name, ':', result);
      return result;
    }
    if (place.lat && place.lng) {
      const result = {
        lat: parseFloat(place.lat),
        lng: parseFloat(place.lng),
      };
      console.log('‚úÖ Coordinates found for', place.name, ':', result);
      return result;
    }
    
    console.warn('‚ö†Ô∏è No coordinates found for place:', place.name, 'attempting to fetch from Google Places API...');
    
    // CRITICAL FIX: If no coordinates found, try to fetch them from Google Places API
    if (place.place_id) {
      try {
        console.log('üîç Fetching coordinates for', place.name, 'with place_id:', place.place_id);
        const placeDetails = await GoogleMapsService.getPlaceDetails(place.place_id);
        if (placeDetails && placeDetails.geometry) {
          const result = {
            lat: placeDetails.geometry.location.lat,
            lng: placeDetails.geometry.location.lng,
          };
          console.log('‚úÖ Successfully fetched coordinates for', place.name, ':', result);
          
          // IMPORTANT: Update the place object with the fetched coordinates so we don't fetch again
          place.coordinates = {
            latitude: result.lat,
            longitude: result.lng,
          };
          
          return result;
        }
      } catch (error) {
        console.error('‚ùå Error fetching coordinates for', place.name, ':', error);
      }
    } else {
      console.warn('‚ö†Ô∏è No place_id available for', place.name, 'cannot fetch coordinates');
    }
    
    console.error('‚ùå Failed to get coordinates for place:', place.name, 'using Philadelphia center as fallback');
    // Return Philadelphia center as fallback instead of 0,0
    return { lat: 39.9526, lng: -75.1652 };
  };

  // Generate complete route coordinates for Polyline (synchronous version)
  const generateCompleteRouteCoordinates = () => {
    const coordinates = [];
    
    try {
      // Add starting location
      coordinates.push({
        latitude: startingLocation.coordinates.latitude,
        longitude: startingLocation.coordinates.longitude
      });
      
      // Process each schedule item in order
      for (const scheduleItem of currentItinerary.schedule || []) {
        // Add dining stops for this segment (if any)
        if (scheduleItem.diningStops && scheduleItem.diningStops.length > 0) {
          for (const diningStop of scheduleItem.diningStops) {
            // Validate dining stop coordinates
            if (diningStop.coordinates && 
                diningStop.coordinates.latitude > 39 && diningStop.coordinates.latitude < 41 &&
                diningStop.coordinates.longitude > -76 && diningStop.coordinates.longitude < -74) {
              coordinates.push({
                latitude: diningStop.coordinates.latitude,
                longitude: diningStop.coordinates.longitude
              });
              console.log('üó∫Ô∏è Added dining stop to route:', diningStop.name);
            }
          }
        }
        
        // Add the main place coordinates (skip for return dining stops)
        if (scheduleItem.place && !scheduleItem.isReturnDining) {
          // Try to get coordinates from the place object
          let placeCoords = null;
          
          // Check multiple coordinate formats
          if (scheduleItem.place.coordinates?.latitude && scheduleItem.place.coordinates?.longitude) {
            placeCoords = {
              latitude: parseFloat(scheduleItem.place.coordinates.latitude),
              longitude: parseFloat(scheduleItem.place.coordinates.longitude)
            };
          } else if (scheduleItem.place.coordinates?.lat && scheduleItem.place.coordinates?.lng) {
            placeCoords = {
              latitude: parseFloat(scheduleItem.place.coordinates.lat),
              longitude: parseFloat(scheduleItem.place.coordinates.lng)
            };
          } else if (scheduleItem.place.basic_info?.latitude && scheduleItem.place.basic_info?.longitude) {
            placeCoords = {
              latitude: parseFloat(scheduleItem.place.basic_info.latitude),
              longitude: parseFloat(scheduleItem.place.basic_info.longitude)
            };
          }
          
          // Only add valid Philadelphia-area coordinates
          if (placeCoords && 
              placeCoords.latitude > 39 && placeCoords.latitude < 41 &&
              placeCoords.longitude > -76 && placeCoords.longitude < -74) {
            coordinates.push(placeCoords);
            console.log('üó∫Ô∏è Added place to route:', scheduleItem.place.name);
          } else {
            console.warn('‚ö†Ô∏è Skipping place with invalid coordinates:', scheduleItem.place.name);
          }
        }
      }
      
      // Add return location if different
      if (returnLocation) {
        coordinates.push({
          latitude: returnLocation.coordinates.latitude,
          longitude: returnLocation.coordinates.longitude
        });
      }
      
      console.log('üó∫Ô∏è Generated route with', coordinates.length, 'points (including dining stops)');
      return coordinates;
    } catch (error) {
      console.error('‚ùå Error generating route coordinates:', error);
      // Fallback to basic route
      return [
        {
          latitude: startingLocation.coordinates.latitude,
          longitude: startingLocation.coordinates.longitude
        }
      ];
    }
  };

  // Generate complete route waypoints including dining stops (async version for state updates)
  const generateCompleteRouteWaypoints = async () => {
    const waypoints = [];
    
    try {
      // Add starting location
      waypoints.push({
        latitude: startingLocation.coordinates.latitude,
        longitude: startingLocation.coordinates.longitude
      });
      
      // Process each schedule item in order
      for (const scheduleItem of currentItinerary.schedule || []) {
        // Add dining stops for this segment (if any)
        if (scheduleItem.diningStops && scheduleItem.diningStops.length > 0) {
          for (const diningStop of scheduleItem.diningStops) {
            // Validate dining stop coordinates
            if (diningStop.coordinates && 
                diningStop.coordinates.latitude > 39 && diningStop.coordinates.latitude < 41 &&
                diningStop.coordinates.longitude > -76 && diningStop.coordinates.longitude < -74) {
              waypoints.push({
                latitude: diningStop.coordinates.latitude,
                longitude: diningStop.coordinates.longitude
              });
              console.log('‚úÖ Added dining stop waypoint:', diningStop.name);
            }
          }
        }
        
        // Add the main place waypoint
        if (scheduleItem.place) {
          try {
            const coords = await extractCoordinates(scheduleItem.place);
            // Only add valid Philadelphia-area coordinates
            if (coords.lat > 39 && coords.lat < 41 && coords.lng > -76 && coords.lng < -74) {
              waypoints.push({
                latitude: coords.lat,
                longitude: coords.lng
              });
              console.log('‚úÖ Added place waypoint:', scheduleItem.place.name);
            }
          } catch (error) {
            console.warn('‚ö†Ô∏è Could not get coordinates for place waypoint:', scheduleItem.place.name);
          }
        }
      }
      
      // Add return location if different
      if (returnLocation) {
        waypoints.push({
          latitude: returnLocation.coordinates.latitude,
          longitude: returnLocation.coordinates.longitude
        });
      }
      
      console.log('üó∫Ô∏è Generated complete route with', waypoints.length, 'waypoints (including dining stops)');
      return waypoints;
    } catch (error) {
      console.error('‚ùå Error generating complete route waypoints:', error);
      return waypoints;
    }
  };
  
  // Update route waypoints in itinerary state
  const updateRouteWaypoints = async () => {
    try {
      const newWaypoints = await generateCompleteRouteWaypoints();
      
      setItineraryState(prevState => {
        if (isMultiDay(prevState)) {
          const updatedDailyItineraries = prevState.dailyItineraries.map(day => {
            if (day.day === activeDay) {
              return { ...day, route: { waypoints: newWaypoints } };
            }
            return day;
          });
          return { ...prevState, dailyItineraries: updatedDailyItineraries };
        } else {
          return { ...prevState, route: { waypoints: newWaypoints } };
        }
      });
      
      console.log('‚úÖ Route waypoints updated successfully');
    } catch (error) {
      console.error('‚ùå Error updating route waypoints:', error);
    }
  };

  // Handle dining stop selection
  const handleDiningStopPress = async (fromIndex: number, toIndex: number) => {
    console.log('üçΩÔ∏è handleDiningStopPress called:', { fromIndex, toIndex });
    
    // Using memoized currentItinerary
    
    // Handle special case of dining before first place (fromIndex = -1)
    if (fromIndex === -1) {
      const toPlace = currentItinerary.schedule[toIndex];
      if (!toPlace) return;

      const toCoords = await extractCoordinates(toPlace.place);
      console.log('üçΩÔ∏è Extracted coordinates for toPlace:', { placeName: toPlace.place.name, coordinates: toCoords });

      setSelectedRouteSegment({
        fromIndex,
        toIndex,
        fromLocation: {
          name: "Starting Point",
          coordinates: {
            lat: startingLocation.coordinates.latitude,
            lng: startingLocation.coordinates.longitude,
          },
        },
        toLocation: {
          name: toPlace.place.name,
          coordinates: toCoords,
        },
        arrivalTime: toPlace.arrivalTime,
      });
      console.log('üçΩÔ∏è Opening dining modal for special case (before first place)');
      setDiningModalVisible(true);
      return;
    }

    // Handle normal case between two places
    const fromPlace = currentItinerary.schedule[fromIndex];
    const toPlace = currentItinerary.schedule[toIndex];

    if (!fromPlace || !toPlace) return;

    // Await both coordinate extractions
    const [fromCoords, toCoords] = await Promise.all([
      extractCoordinates(fromPlace.place),
      extractCoordinates(toPlace.place)
    ]);
    
    console.log('üçΩÔ∏è Extracted coordinates:', { 
      fromPlace: fromPlace.place.name, 
      fromCoords, 
      toPlace: toPlace.place.name, 
      toCoords 
    });

    setSelectedRouteSegment({
      fromIndex,
      toIndex,
      fromLocation: {
        name: fromPlace.place.name,
        coordinates: fromCoords,
      },
      toLocation: {
        name: toPlace.place.name,
        coordinates: toCoords,
      },
      arrivalTime: toPlace.arrivalTime,
    });
    console.log('üçΩÔ∏è Opening dining modal for normal case (between places)');
    setDiningModalVisible(true);
  };

  // Handle return dining stop press (dining between last place and return)
  const handleReturnDiningStopPress = () => {
    // Using memoized currentItinerary
    
    if (!currentItinerary || !currentItinerary.schedule || currentItinerary.schedule.length === 0) {
      return;
    }

    const lastPlace = currentItinerary.schedule[currentItinerary.schedule.length - 1];
    const returnAddr = returnLocation?.address || startingLocation.address;
    if (!lastPlace || !returnAddr) {
      return;
    }

    // Check if return dining stop already exists (extra schedule item)
    if (currentItinerary.schedule.length > currentItinerary.places.length) {
      const returnScheduleItem = currentItinerary.schedule[currentItinerary.schedule.length - 1];
      const firstDiningStop = returnScheduleItem.diningStops?.[0];
      if (firstDiningStop) {
        // Show options to view/edit/remove existing dining stop
        Alert.alert(
          'Return Dining Stop',
          `You already have a dining stop: ${firstDiningStop.name}`,
          [
            { text: 'Remove', style: 'destructive', onPress: () => removeReturnDiningStop() },
            { text: 'Change', style: 'default', onPress: () => openReturnDiningModal() },
            { text: 'Cancel', style: 'cancel' }
          ]
        );
        return;
      }
    }

    // Open dining modal for new return dining stop
    openReturnDiningModal();
  };

  // Open return dining modal
  const openReturnDiningModal = async () => {
    // Using memoized currentItinerary
    const lastPlace = currentItinerary.schedule[currentItinerary.schedule.length - 1];
    const returnAddr = returnLocation?.address || startingLocation.address;
    
    if (!lastPlace || !returnAddr) return;

    const fromCoords = await extractCoordinates(lastPlace.place);
    console.log('üçΩÔ∏è Extracted coordinates for return dining:', { 
      lastPlace: lastPlace.place.name, 
      fromCoords,
      originalPlaceObject: lastPlace.place
    });

    // Additional validation for fromCoords
    if (!fromCoords || fromCoords.lat === 39.9526 && fromCoords.lng === -75.1652) {
      console.warn('‚ö†Ô∏è Using fallback coordinates for last place, trying to get from places array');
      // Try to get coordinates from the places array instead
      const lastPlaceFromArray = currentItinerary.places[currentItinerary.places.length - 1];
      if (lastPlaceFromArray) {
        const fallbackCoords = await extractCoordinates(lastPlaceFromArray);
        console.log('üîÑ Fallback coordinates:', { fallbackCoords });
        if (fallbackCoords && !(fallbackCoords.lat === 39.9526 && fallbackCoords.lng === -75.1652)) {
          fromCoords.lat = fallbackCoords.lat;
          fromCoords.lng = fallbackCoords.lng;
        }
      }
    }

    // Get return coordinates with proper validation
    const returnCoords = {
      lat: returnLocation?.coordinates.latitude || startingLocation.coordinates.latitude,
      lng: returnLocation?.coordinates.longitude || startingLocation.coordinates.longitude,
    };

    // Validate both coordinates are valid Philadelphia area coordinates
    if (!fromCoords || !returnCoords || 
        fromCoords.lat < 39 || fromCoords.lat > 41 || fromCoords.lng < -76 || fromCoords.lng > -74 ||
        returnCoords.lat < 39 || returnCoords.lat > 41 || returnCoords.lng < -76 || returnCoords.lng > -74) {
      console.error('‚ùå Invalid coordinates for return dining:', { fromCoords, returnCoords });
      Alert.alert('Error', 'Unable to add dining stop - invalid location coordinates');
      return;
    }

    console.log('üçΩÔ∏è Return dining coordinates validated:', { 
      fromCoords, 
      returnCoords,
      lastPlace: lastPlace.place.name,
      returnAddr
    });

    // Set up special route segment for return journey (use index -2 to indicate return dining stop)
    setSelectedRouteSegment({
      fromIndex: -2, // Special index for return dining stop
      toIndex: -1,   // Special index for return destination
      fromLocation: {
        name: lastPlace.place.name,
        coordinates: fromCoords,
      },
      toLocation: {
        name: returnAddr,
        coordinates: returnCoords,
      },
      arrivalTime: lastPlace.departureTime,
    });
    console.log('üçΩÔ∏è Opening dining modal for return journey');
    setDiningModalVisible(true);
  };

  // Remove return dining stop
  const removeReturnDiningStop = () => {
    setItineraryState(prevState => {
      try {
        if (isMultiDay(prevState)) {
          const updatedDailyItineraries = prevState.dailyItineraries.map(day => {
            if (day.day === activeDay) {
              // Check if the last schedule item is a return dining stop (schedule length > places length)
              if (day.schedule.length > day.places.length) {
                // Remove the extra schedule item
                return { ...day, schedule: day.schedule.slice(0, -1) };
              }
            }
            return day;
          });
          
          console.log('üóëÔ∏è Return dining stop removed from multi-day itinerary');
          
          // Recalculate schedule
          const updatedState = { ...prevState, dailyItineraries: updatedDailyItineraries };
          return calculateUnifiedSchedule(updatedState, activeDay - 1);
        } else {
          // Check if the last schedule item is a return dining stop (schedule length > places length)
          if (prevState.schedule.length > prevState.places.length) {
            // Remove the extra schedule item
            const updatedState = { ...prevState, schedule: prevState.schedule.slice(0, -1) };
            
            console.log('üóëÔ∏è Return dining stop removed from single-day itinerary');
            
            // Recalculate schedule
            return calculateUnifiedSchedule(updatedState, undefined);
          }
        }
        return prevState;
      } catch (error) {
        console.error('Error removing return dining stop:', error);
        Alert.alert('Error', 'Failed to remove return dining stop. Please try again.');
        return prevState;
      }
    });
    
    // Update route waypoints to remove the return dining stop
    setTimeout(() => {
      updateRouteWaypoints();
    }, 100); // Small delay to ensure state update is processed
  };

  // Handle dining option selection
  const handleDiningSelected = async (diningOption: DiningOption, mealType: string) => {
    console.log('üçΩÔ∏è handleDiningSelected called:', {
      diningOption: diningOption.name,
      mealType: mealType,
      selectedRouteSegment: selectedRouteSegment
    });
    
    if (!selectedRouteSegment) {
      console.error('‚ùå No selected route segment');
      return;
    }

    let travelBreakdown;
    
    try {
      // Calculate detailed travel time breakdown using Google Routes API
      travelBreakdown = await DiningService.calculateTravelTimeBreakdown(
        diningOption.geometry.location.lat,
        diningOption.geometry.location.lng,
        selectedRouteSegment.fromLocation.coordinates.lat,
        selectedRouteSegment.fromLocation.coordinates.lng,
        selectedRouteSegment.toLocation.coordinates.lat,
        selectedRouteSegment.toLocation.coordinates.lng
      );
    } catch (error) {
      console.error('‚ùå Error calculating travel breakdown with Google Routes API:', error);
      console.error('Error details:', {
        selectedRouteSegment: selectedRouteSegment,
        diningOptionName: diningOption.name,
        diningOptionCoords: diningOption.geometry.location,
        error: error instanceof Error ? error.message : 'Unknown error'
      });
      
      // Use fallback values if the API call fails
      travelBreakdown = {
        travelToRestaurant: 10,
        travelFromRestaurant: 10,
        totalExtraTravel: 5,
        directRouteTime: 15,
        travelToMode: 'driving' as const,
        travelFromMode: 'driving' as const,
        travelToIcon: 'üöó',
        travelFromIcon: 'üöó',
      };
      
      console.log('üçΩÔ∏è Using fallback travel breakdown values');
    }



    const diningDuration = DiningService.calculateDiningDuration(
      mealType,
      (diningOption as any).popular_times?.typical_time_spent
    );

    // Ensure all calculated values are valid numbers
    const validTravelTo = typeof travelBreakdown.travelToRestaurant === 'number' && !isNaN(travelBreakdown.travelToRestaurant) ? 
                         travelBreakdown.travelToRestaurant : 5;
    const validTravelFrom = typeof travelBreakdown.travelFromRestaurant === 'number' && !isNaN(travelBreakdown.travelFromRestaurant) ? 
                           travelBreakdown.travelFromRestaurant : 5;
    const validDiningDuration = typeof diningDuration === 'number' && !isNaN(diningDuration) ? diningDuration : 30;
    const validExtraTravel = typeof travelBreakdown.totalExtraTravel === 'number' && !isNaN(travelBreakdown.totalExtraTravel) ? 
                            travelBreakdown.totalExtraTravel : 0;
    const validDirectRoute = typeof travelBreakdown.directRouteTime === 'number' && !isNaN(travelBreakdown.directRouteTime) ? 
                            travelBreakdown.directRouteTime : 10;

    // Calculate arrival and departure times for the dining stop
    const calculateDiningTimes = () => {
      // Using memoized currentItinerary
      
      if (selectedRouteSegment.fromIndex === -1) {
        // Dining before first place - start from trip start time
        const firstPlace = currentItinerary.schedule[0];
        if (firstPlace && firstPlace.arrivalTime) {
          const tripStartMinutes = timeStringToMinutes(firstPlace.arrivalTime) - (currentItinerary.places[0]?.travelTimeFromPrevious || 15);
          const arrivalMinutes = tripStartMinutes + validTravelTo;
          const departureMinutes = arrivalMinutes + validDiningDuration;
          
          return {
            arrival_time: minutesToTimeString(arrivalMinutes),
            departure_time: minutesToTimeString(departureMinutes)
          };
        }
      } else if (selectedRouteSegment.fromIndex === -2) {
        // Return dining stop - start from last place departure time
        const lastPlace = currentItinerary.schedule[currentItinerary.schedule.length - 1];
        if (lastPlace && lastPlace.departureTime) {
          const departureMinutes = timeStringToMinutes(lastPlace.departureTime);
          const arrivalMinutes = departureMinutes + validTravelTo;
          const departureFromRestaurant = arrivalMinutes + validDiningDuration;
          
          return {
            arrival_time: minutesToTimeString(arrivalMinutes),
            departure_time: minutesToTimeString(departureFromRestaurant)
          };
        }
      } else {
        // Dining between places - start from previous place departure
        const fromPlace = currentItinerary.schedule[selectedRouteSegment.fromIndex];
        if (fromPlace && fromPlace.departureTime) {
          const departureMinutes = timeStringToMinutes(fromPlace.departureTime);
          const arrivalMinutes = departureMinutes + validTravelTo;
          const departureFromRestaurant = arrivalMinutes + validDiningDuration;
          
          return {
            arrival_time: minutesToTimeString(arrivalMinutes),
            departure_time: minutesToTimeString(departureFromRestaurant)
          };
        }
      }
      
      return { arrival_time: 'TBD', departure_time: 'TBD' };
    };

    // Helper functions for time calculations
    const timeStringToMinutes = (timeStr: string): number => {
      const [hours, minutes] = timeStr.split(':').map(Number);
      return hours * 60 + minutes;
    };

    const minutesToTimeString = (minutes: number): string => {
      const hours = Math.floor(minutes / 60);
      const mins = minutes % 60;
      return `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;
    };

    const diningTimes = calculateDiningTimes();
    
    console.log('üçΩÔ∏è DINING STOP TRAVEL MODE DEBUG:', {
      diningStopName: diningOption.name,
      travelToRestaurant: validTravelTo,
      travelFromRestaurant: validTravelFrom,
      travelToMode: travelBreakdown.travelToMode,
      travelFromMode: travelBreakdown.travelFromMode,
      travelToOptions: travelBreakdown.travelToOptions,
      travelFromOptions: travelBreakdown.travelFromOptions,
      autoSelectedToMode: travelBreakdown.travelToMode || 'driving',
      autoSelectedFromMode: travelBreakdown.travelFromMode || 'driving'
    });
    
    console.log('DINING TIMES CALCULATED:', JSON.stringify({
      diningStopName: diningOption.name,
      arrivalTime: diningTimes.arrival_time,
      departureTime: diningTimes.departure_time,
      diningDuration: validDiningDuration,
      travelTo: validTravelTo,
      travelFrom: validTravelFrom
    }, null, 2));

    const diningStop: DiningStop = {
      place_id: diningOption.place_id,
      name: diningOption.name,
      address: diningOption.vicinity,
      coordinates: {
        latitude: diningOption.geometry.location.lat,
        longitude: diningOption.geometry.location.lng,
      },
      rating: diningOption.rating,
      user_ratings_total: diningOption.user_ratings_total,
      price_level: diningOption.price_level,
      meal_type: mealType,
      detour_distance: diningOption.distance_from_route || 0,
      detour_time: validExtraTravel, // Legacy field for backward compatibility
      dining_duration: validDiningDuration,
      typical_time_spent: (diningOption as any).popular_times?.typical_time_spent,
      arrival_time: diningTimes.arrival_time,
      departure_time: diningTimes.departure_time,
      travel_breakdown: {
        travel_to_restaurant: validTravelTo,
        travel_from_restaurant: validTravelFrom,
        total_extra_travel: validExtraTravel,
        direct_route_time: validDirectRoute,
        travel_to_mode: travelBreakdown.travelToMode || 'driving',
        travel_from_mode: travelBreakdown.travelFromMode || 'driving',
        travel_to_icon: (travelBreakdown.travelToMode || 'driving') === 'walking' ? 'üö∂' : 'üöó',
        travel_from_icon: (travelBreakdown.travelFromMode || 'driving') === 'walking' ? 'üö∂' : 'üöó',
        // Add the travel options data that DualTravelIndicator needs
        travelToOptions: travelBreakdown.travelToOptions,
        travelFromOptions: travelBreakdown.travelFromOptions,
      },
      total_stop_impact: validTravelTo + validDiningDuration + validTravelFrom,
      photos: diningOption.photos,
    };


    console.log('üçΩÔ∏è Dining stop created:', {
      name: diningStop.name,
      mealType: diningStop.meal_type,
      arrivalTime: diningStop.arrival_time,
      departureTime: diningStop.departure_time,
      totalImpact: diningStop.total_stop_impact
    });
    
    setDiningModalVisible(false);
    setSelectedRouteSegment(null);
    
    // Update the itinerary state and recalculate schedule
    setItineraryState(prevState => {
      try {
        console.log('üçΩÔ∏è Updating itinerary state with dining stop...');

        // First, add the dining stop to the schedule
        let updatedState;
        if (isMultiDay(prevState)) {
          const updatedDailyItineraries = prevState.dailyItineraries.map(day => {
            if (day.day === activeDay) {
              if (selectedRouteSegment.fromIndex === -2) {
                // Handle return dining stop case: create a new schedule item AFTER the last place
                const newScheduleItem = {
                  place: day.places[day.places.length - 1], // Use last place as placeholder
                  arrivalTime: diningStop.arrival_time || '00:00',
                  departureTime: diningStop.departure_time || '00:00',
                  visitDuration: 0, // This is just for the dining stop
                  diningStops: [diningStop],
                  isReturnDining: true // Mark this as a return dining stop
                };
                
                return { ...day, schedule: [...day.schedule, newScheduleItem] };
              } else {
                // Handle other cases normally
                const updatedSchedule = day.schedule.map((item, index) => {
                  console.log(`üçΩÔ∏è Checking schedule item ${index}:`, {
                    placeName: item.place?.name,
                    fromIndex: selectedRouteSegment.fromIndex,
                    toIndex: selectedRouteSegment.toIndex,
                    shouldAddToThisItem: (selectedRouteSegment.fromIndex === -1 && index === 0) || 
                                        (selectedRouteSegment.fromIndex !== -1 && index === selectedRouteSegment.toIndex)
                  });
                  
                  // Handle special case: dining before first place (fromIndex = -1)
                  if (selectedRouteSegment.fromIndex === -1 && index === 0) {
                    console.log(`üçΩÔ∏è Adding dining stop to first place (${item.place?.name})`);
                    return {
                      ...item,
                      diningStops: [...(item.diningStops || []), diningStop],
                    };
                  }
                  // Handle normal case: dining between places
                  else if (selectedRouteSegment.fromIndex !== -1 && index === selectedRouteSegment.toIndex) {
                    console.log(`üçΩÔ∏è Adding dining stop to place ${index} (${item.place?.name})`);
                    return {
                      ...item,
                      diningStops: [...(item.diningStops || []), diningStop],
                    };
                  }
                  return item;
                });
                return { ...day, schedule: updatedSchedule };
              }
            }
            return day;
          });
          updatedState = { ...prevState, dailyItineraries: updatedDailyItineraries };
        } else {
          if (selectedRouteSegment.fromIndex === -2) {
            // Handle return dining stop case: create a new schedule item AFTER the last place
            const newScheduleItem = {
              place: prevState.places[prevState.places.length - 1], // Use last place as placeholder
              arrivalTime: diningStop.arrival_time || '00:00',
              departureTime: diningStop.departure_time || '00:00',
              visitDuration: 0, // This is just for the dining stop
              diningStops: [diningStop],
              isReturnDining: true // Mark this as a return dining stop
            };
            
            updatedState = { ...prevState, schedule: [...prevState.schedule, newScheduleItem] };
          } else {
            // Handle other cases normally
            const updatedSchedule = prevState.schedule.map((item, index) => {
              // Handle special case: dining before first place (fromIndex = -1)
              if (selectedRouteSegment.fromIndex === -1 && index === 0) {
                return {
                  ...item,
                  diningStops: [...(item.diningStops || []), diningStop],
                };
              }
              // Handle normal case: dining between places
              else if (selectedRouteSegment.fromIndex !== -1 && index === selectedRouteSegment.toIndex) {
                return {
                  ...item,
                  diningStops: [...(item.diningStops || []), diningStop],
                };
              }
              return item;
            });
            updatedState = { ...prevState, schedule: updatedSchedule };
          }
        }

        console.log('üçΩÔ∏è Dining stop added to schedule, recalculating...');
        
        // Then recalculate the schedule with proper timing
        const recalculatedState = calculateUnifiedSchedule(updatedState, isMultiDay(updatedState) ? activeDay - 1 : undefined);
        
        // Validate the recalculated state
        if (!recalculatedState || (isMultiDay(recalculatedState) && !recalculatedState.dailyItineraries) ||
            (!isMultiDay(recalculatedState) && !recalculatedState.schedule)) {
          console.warn('Invalid recalculated state, using updated state without recalculation');
          return updatedState;
        }
        
        console.log('‚úÖ Dining stop successfully added and schedule recalculated');
        return recalculatedState;
      } catch (error) {
        console.error('Error updating and recalculating schedule:', error);
        return prevState; // Return original state if anything fails
      }
    });
    
    // Update route waypoints to include the new dining stop
    setTimeout(() => {
      updateRouteWaypoints();
    }, 100); // Small delay to ensure state update is processed
  };

  // Handle dining stop editing
  const handleDiningStopEdit = (
    diningStop: DiningStop,
    itemIndex: number,
    stopIndex: number
  ) => {
    setEditingDiningStop({ stop: diningStop, itemIndex, stopIndex });
  };

  // Handle dining stop update
  const handleDiningStopUpdate = (updatedStop: DiningStop) => {
    if (!editingDiningStop) return;

    setItineraryState(prevState => {
      let newState;
      if (isMultiDay(prevState)) {
        const updatedDailyItineraries = prevState.dailyItineraries.map(day => {
          if (day.day === activeDay) {
            const updatedSchedule = day.schedule.map((item, index) => {
              if (index === editingDiningStop.itemIndex) {
                const updatedDiningStops = [...(item.diningStops || [])];
                updatedDiningStops[editingDiningStop.stopIndex] = updatedStop;
                return { ...item, diningStops: updatedDiningStops };
              }
              return item;
            });
            return { ...day, schedule: updatedSchedule };
          }
          return day;
        });
        newState = { ...prevState, dailyItineraries: updatedDailyItineraries };
      } else {
        const updatedSchedule = prevState.schedule.map((item, index) => {
          if (index === editingDiningStop.itemIndex) {
            const updatedDiningStops = [...(item.diningStops || [])];
            updatedDiningStops[editingDiningStop.stopIndex] = updatedStop;
            return { ...item, diningStops: updatedDiningStops };
          }
          return item;
        });
        newState = { ...prevState, schedule: updatedSchedule };
      }
      
      // Recalculate schedule
      try {
        const recalculatedState = calculateUnifiedSchedule(newState, activeDay - 1);
        
        // Validate the recalculated state
        if (!recalculatedState || (isMultiDay(recalculatedState) && !recalculatedState.dailyItineraries) ||
            (!isMultiDay(recalculatedState) && !recalculatedState.schedule)) {
          console.warn('Invalid recalculated state during update, reverting to newState');
          return newState;
        }
        
        return recalculatedState;
      } catch (error) {
        console.error('Error recalculating schedule during update:', error);
        return newState;
      }
    });

    setEditingDiningStop(null);
  };

  // Handle dining stop removal
  const handleRemoveDiningStop = (
    diningStop: DiningStop,
    itemIndex: number,
    stopIndex: number
  ) => {
    setItineraryState(prevState => {
      let newState;
      if (isMultiDay(prevState)) {
        const updatedDailyItineraries = prevState.dailyItineraries.map(day => {
          if (day.day === activeDay) {
            const updatedSchedule = day.schedule.map((item, idx) => {
              if (idx === itemIndex && item.diningStops) {
                return {
                  ...item,
                  diningStops: item.diningStops.filter((_, dsIdx) => dsIdx !== stopIndex),
                };
              }
              return item;
            });
            return { ...day, schedule: updatedSchedule };
          }
          return day;
        });
        newState = { ...prevState, dailyItineraries: updatedDailyItineraries };
      } else {
        const updatedSchedule = prevState.schedule.map((item, idx) => {
          if (idx === itemIndex && item.diningStops) {
            return {
              ...item,
              diningStops: item.diningStops.filter((_, dsIdx) => dsIdx !== stopIndex),
            };
          }
          return item;
        });
        newState = { ...prevState, schedule: updatedSchedule };
      }

      // CRITICAL FIX: Transfer dining stops from schedule to places before recalculation
      const stateWithDiningStops = { ...newState };
      
      if (isMultiDay(newState)) {
        const day = newState.dailyItineraries[activeDay - 1];
        if (day && day.schedule && day.places) {
          console.log('üçΩÔ∏è Transferring dining stops from schedule to places for multi-day itinerary after removal');
          const updatedPlaces = day.places.map((place: any, index: number) => {
            const scheduleItem = day.schedule[index];
            if (scheduleItem && scheduleItem.diningStops && scheduleItem.diningStops.length > 0) {
              console.log(`üçΩÔ∏è Found ${scheduleItem.diningStops.length} dining stops for place ${index} (${place.name}) after removal`);
              return { ...place, diningStops: scheduleItem.diningStops };
            }
            return { ...place, diningStops: [] }; // Clear dining stops if none in schedule
          });
          
          const updatedDay = { ...day, places: updatedPlaces };
          const updatedDailyItineraries = [...newState.dailyItineraries];
          updatedDailyItineraries[activeDay - 1] = updatedDay;
          stateWithDiningStops.dailyItineraries = updatedDailyItineraries;
        }
      } else {
        if (newState.schedule && newState.places) {
          console.log('üçΩÔ∏è Transferring dining stops from schedule to places for single-day itinerary after removal');
          const updatedPlaces = newState.places.map((place: any, index: number) => {
            const scheduleItem = newState.schedule[index];
            if (scheduleItem && scheduleItem.diningStops && scheduleItem.diningStops.length > 0) {
              console.log(`üçΩÔ∏è Found ${scheduleItem.diningStops.length} dining stops for place ${index} (${place.name}) after removal`);
              return { ...place, diningStops: scheduleItem.diningStops };
            }
            return { ...place, diningStops: [] }; // Clear dining stops if none in schedule
          });
          
          stateWithDiningStops.places = updatedPlaces;
        }
      }

      // Recalculate schedule after removal
      try {
        const recalculatedState = calculateUnifiedSchedule(stateWithDiningStops, activeDay - 1);
        
        if (!recalculatedState || (isMultiDay(recalculatedState) && !recalculatedState.dailyItineraries) ||
            (!isMultiDay(recalculatedState) && !recalculatedState.schedule)) {
          console.warn('Invalid recalculated state during removal, reverting to newState');
          return newState;
        }
        
        console.log('‚úÖ Dining stop removed and schedule recalculated successfully');
        return recalculatedState;
      } catch (error) {
        console.error('Error recalculating schedule during removal:', error);
        return newState;
      }
    });
  };

  // Check if a place is open at a specific time
  const isPlaceOpenAtTime = (place: any, visitTime: string, visitDate?: Date): { isOpen: boolean; reason?: string } => {
    try {
      // Check if place has hours data (either opening_hours or hours field)
      const hoursData = place.opening_hours || place.hours;
      if (!hoursData) {
        return { isOpen: true }; // Assume open if no hours specified
      }

      const currentDate = visitDate || new Date();
      const dayOfWeek = currentDate.getDay(); // 0 = Sunday, 1 = Monday, etc.
      const timeToCheck = visitTime.replace(':', ''); // Convert "14:30" to "1430"
      
      // Map day numbers to day names
      const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
      const todayName = dayNames[dayOfWeek];
      
      // Handle the structured hours format from our data
      if (hoursData[todayName]) {
        const dayHours = hoursData[todayName];
        
        // Check if closed
        if (dayHours.opens === 'Closed' || !dayHours.opens) {
          return { isOpen: false, reason: 'Closed today' };
        }
        
        // Check for "Open 24 hours"
        if (dayHours.opens === 'Open 24 hours') {
          return { isOpen: true };
        }
        
        // Parse opening and closing times
        const openTime = dayHours.opens;
        const closeTime = dayHours.closes;
        
        if (openTime && closeTime) {
          // Extract time components (e.g., "10 AM" -> 10, "AM")
          const openMatch = openTime.match(/(\d{1,2})\s*(AM|PM)/i);
          const closeMatch = closeTime.match(/(\d{1,2})\s*(AM|PM)/i);
          
          if (openMatch && closeMatch) {
            const [, openHour, openAmPm] = openMatch;
            const [, closeHour, closeAmPm] = closeMatch;
            
            // Convert to 24-hour format
            let openTime24 = parseInt(openHour, 10);
            if (openAmPm.toLowerCase() === 'pm' && openTime24 !== 12) openTime24 += 12;
            if (openAmPm.toLowerCase() === 'am' && openTime24 === 12) openTime24 = 0;
            
            let closeTime24 = parseInt(closeHour, 10);
            if (closeAmPm.toLowerCase() === 'pm' && closeTime24 !== 12) closeTime24 += 12;
            if (closeAmPm.toLowerCase() === 'am' && closeTime24 === 12) closeTime24 = 0;
            
            const openTimeStr = openTime24.toString().padStart(2, '0') + '00';
            const closeTimeStr = closeTime24.toString().padStart(2, '0') + '00';
            
            // Check if visit time is within opening hours
            if (timeToCheck >= openTimeStr && timeToCheck <= closeTimeStr) {
              return { isOpen: true };
            } else {
              if (timeToCheck < openTimeStr) {
                return { isOpen: false, reason: `Opens at ${openTime}` };
              } else {
                return { isOpen: false, reason: `Closed at ${closeTime}` };
              }
            }
          }
        }
      }
      
      // Handle legacy weekday_text format (array of strings)
      if (Array.isArray(hoursData.weekday_text)) {
        const dayNamesLong = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
        const todayNameLong = dayNamesLong[dayOfWeek];
        
        const todayHours = hoursData.weekday_text.find(day => 
          day.toLowerCase().includes(todayNameLong.toLowerCase())
        );
        
        if (todayHours && todayHours.toLowerCase().includes('closed')) {
          return { isOpen: false, reason: 'Closed today' };
        }
      }
      
      // If we can't parse the hours, assume open
      return { isOpen: true };
    } catch (error) {
      console.warn('Error checking opening hours:', error);
      return { isOpen: true }; // Default to open if error
    }
  };


  // Handle place change request
  const handleChangePlacePress = async (place: PlaceRecommendation, index: number) => {
    setLoadingAlternatives(true);
    
    try {
      // Get alternative places and check their opening hours
      const scheduleItem = currentItinerary.schedule.find(s => s.place.place_id === place.place_id);
      const visitTime = scheduleItem?.arrivalTime || '12:00';
      
      // Get visit date - for multi-day itineraries, use the specific day
      let visitDate = new Date();
      if (isMultiDay(currentItinerary)) {
        const multiDayItinerary = currentItinerary as MultiDayItinerary;
        if (multiDayItinerary.dates && multiDayItinerary.dates.length >= activeDay) {
          visitDate = new Date(multiDayItinerary.dates[activeDay - 1]);
        }
      }
      
      // Get all available places from DataService
      const allPlaces = DataService.getAllPlaces();
      if (!allPlaces || allPlaces.length === 0) {
        throw new Error('No places data available');
      }
      
      // Filter and map alternative places with opening hours check
      const alternatives = allPlaces
        .filter((altPlace: any) => {
          // Exclude current place and already selected places
          if (altPlace.place_id === place.place_id) return false;
          if (currentItinerary.places.some(p => p.place_id === altPlace.place_id)) return false;
          
          // Must be a tourist attraction
          if (!altPlace.types?.some((type: string) => 
            type.toLowerCase().includes('tourist_attraction')
          )) return false;
          
          return true; // Include all attractions, we'll mark closed ones in the UI
        })
        .map((altPlace: any) => {
          // Check opening hours for this place
          const openingStatus = isPlaceOpenAtTime(altPlace, visitTime, visitDate);
          
          // Debug log for testing (Philadelphia Museum of Art specific check)
          if (altPlace.name.includes('Philadelphia Museum of Art')) {
            // Opening hours check for debugging
          }
          
          return {
            ...altPlace,
            matchScore: 0.8,
            estimatedVisitDuration: ItineraryService.calculateVisitDuration(altPlace),
            travelTimeFromPrevious: place.travelTimeFromPrevious || 15,
            travelMode: place.travelMode || 'driving',
            travelIcon: place.travelIcon || 'üöó',
            isOpen: openingStatus.isOpen,
            closedReason: openingStatus.reason,
          };
        });
      
      setChangingPlace({
        place,
        index,
        alternatives,
        visitTime,
        visitDate
      });
      
    } catch (error) {
      console.error('Error loading alternative places:', error);
      Alert.alert(
        'Error', 
        'Could not load alternative places. Please try again.',
        [{ text: 'OK' }]
      );
    } finally {
      setLoadingAlternatives(false);
    }
  };

  // Handle place replacement
  const handlePlaceReplace = async (newPlace: PlaceRecommendation) => {
    if (!changingPlace) return;
    
    try {
      console.log('üîÑ Starting place replacement for:', newPlace.name, 'place_id:', newPlace.place_id);
      
      // CRITICAL FIX: Fetch coordinates for the new place if missing
      let placeWithCoordinates = { ...newPlace };
      
      if (!newPlace.coordinates && !newPlace.basic_info?.latitude && !newPlace.latitude) {
        console.log('üîç Fetching coordinates for replaced place:', newPlace.name);
        try {
          const placeDetails = await GoogleMapsService.getPlaceDetails(newPlace.place_id);
          if (placeDetails && placeDetails.geometry) {
            placeWithCoordinates.coordinates = {
              latitude: placeDetails.geometry.location.lat,
              longitude: placeDetails.geometry.location.lng,
            };
            console.log('‚úÖ Fetched coordinates for', newPlace.name, ':', placeWithCoordinates.coordinates);
          } else {
            console.warn('‚ö†Ô∏è Could not fetch coordinates for place:', newPlace.name);
          }
        } catch (coordError) {
          console.error('‚ùå Error fetching coordinates:', coordError);
        }
      } else {
        console.log('‚úÖ Place already has coordinates:', newPlace.name);
      }
      
      // First, calculate proper travel times for the new place
      let placeWithTravelTime = { ...placeWithCoordinates };
      
      // Calculate travel time from previous location if this isn't the first place
      if (changingPlace.index > 0) {
        try {
          const currentItinerary = isMultiDay(itineraryState) 
            ? itineraryState.dailyItineraries.find(day => day.day === activeDay)
            : itineraryState;
          
          if (currentItinerary) {
            const previousPlace = currentItinerary.places[changingPlace.index - 1];
            if (previousPlace) {
              // Calculating travel time between places
              
              try {
                const travelInfo = await GoogleMapsService.getSmartTravelTime(
                  previousPlace,
                  placeWithCoordinates
                );
                
                placeWithTravelTime = {
                  ...placeWithCoordinates,
                  travelTimeFromPrevious: travelInfo.duration,
                  travelMode: travelInfo.mode,
                  travelIcon: travelInfo.icon,
                  estimatedVisitDuration: placeWithCoordinates.estimatedVisitDuration || 60
                };
                
                
                // Check if emergency fallback was used
                if (travelInfo.icon === '‚ö†Ô∏è') {
                  Alert.alert(
                    'Travel Time Warning',
                    `Travel time calculated using fallback method between ${previousPlace.name} and ${placeWithCoordinates.name}. Accuracy may be limited.`,
                    [{ text: 'Continue', style: 'default' }]
                  );
                }
                
                // Updated place with travel time
              } catch (travelError) {
                console.warn('Travel time calculation failed, using fallback:', travelError);
                // Use fallback instead of stopping the process
                placeWithTravelTime = {
                  ...placeWithCoordinates,
                  travelTimeFromPrevious: 20, // 20 minute fallback
                  travelMode: 'driving',
                  travelIcon: '‚ö†Ô∏è',
                  estimatedVisitDuration: placeWithCoordinates.estimatedVisitDuration || 60
                };
                
                Alert.alert(
                  'Travel Time Warning',
                  `Could not calculate exact travel time between ${previousPlace.name} and ${placeWithCoordinates.name}. Using 20-minute estimate.`,
                  [{ text: 'Continue', style: 'default' }]
                );
              }
            }
          }
        } catch (error) {
          console.warn('Failed to calculate travel time, using defaults:', error);
          // Fallback to defaults if travel time calculation fails
          placeWithTravelTime = {
            ...placeWithCoordinates,
            travelTimeFromPrevious: 20, // 20 minute fallback
            travelMode: 'driving',
            travelIcon: '‚ö†Ô∏è',
            estimatedVisitDuration: placeWithCoordinates.estimatedVisitDuration || 60
          };
        }
      } else {
        // First place: calculate travel time from starting location
        try {
          if (startingLocation) {
            // Calculating travel time from starting location
            
            // Create a place-like object for starting location
            const startingPlace = {
              name: startingLocation.address,
              coordinates: startingLocation.coordinates
            };
            
            try {
              const travelInfoFromStart = await GoogleMapsService.getSmartTravelTime(
                startingPlace,
                placeWithCoordinates
              );
              
              placeWithTravelTime = {
                ...placeWithCoordinates,
                travelTimeFromPrevious: travelInfoFromStart.duration,
                travelMode: travelInfoFromStart.mode,
                travelIcon: travelInfoFromStart.icon,
                estimatedVisitDuration: placeWithCoordinates.estimatedVisitDuration || 60
              };
              
              // Updated first place with travel time from start
            } catch (travelError) {
              console.warn('Starting location travel time calculation failed, using fallback:', travelError);
              // Use fallback instead of stopping the process
              placeWithTravelTime = {
                ...placeWithCoordinates,
                travelTimeFromPrevious: 20, // 20 minute fallback
                travelMode: 'driving',
                travelIcon: '‚ö†Ô∏è',
                estimatedVisitDuration: placeWithCoordinates.estimatedVisitDuration || 60
              };
              
              Alert.alert(
                'Travel Time Warning',
                `Could not calculate exact travel time from starting location to ${placeWithCoordinates.name}. Using 20-minute estimate.`,
                [{ text: 'Continue', style: 'default' }]
              );
            }
          } else {
            // Fallback if no starting location found
            placeWithTravelTime = {
              ...placeWithCoordinates,
              travelTimeFromPrevious: 20, // 20 minute fallback
              travelMode: 'driving',
              travelIcon: '‚ö†Ô∏è',
              estimatedVisitDuration: placeWithCoordinates.estimatedVisitDuration || 60
            };
            console.warn('No starting location found, using 20-minute estimate for first place');
          }
        } catch (error) {
          console.warn('Failed to calculate travel time from starting point, using defaults:', error);
          // Fallback to defaults if travel time calculation fails
          placeWithTravelTime = {
            ...placeWithCoordinates,
            travelTimeFromPrevious: 20, // 20 minute fallback
            travelMode: 'driving',
            travelIcon: '‚ö†Ô∏è',
            estimatedVisitDuration: placeWithCoordinates.estimatedVisitDuration || 60
          };
        }
      }
      
      // Calculate travel time to next place if it exists
      let updatedNextPlace = null;
      const currentItinerary = isMultiDay(itineraryState) 
        ? itineraryState.dailyItineraries.find(day => day.day === activeDay)
        : itineraryState;
      
      // If this is the last place, calculate return travel time
      
      if (currentItinerary && changingPlace.index === currentItinerary.places.length - 1) {
        try {
          // Get return location coordinates (fallback to starting location if no different return location)
          const returnLoc = returnLocation || startingLocation;
          if (returnLoc) {
            // Calculating return travel time
            
            // Create a place-like object for return location
            const returnPlace = {
              name: returnLoc.address,
              coordinates: returnLoc.coordinates
            };
            
            try {
              const returnTravelInfo = await GoogleMapsService.getSmartTravelTime(
                placeWithTravelTime,
                returnPlace
              );
              
              // Update the place with return travel information
              placeWithTravelTime = {
                ...placeWithTravelTime,
                returnTravelTime: returnTravelInfo.duration,
                returnTravelMode: returnTravelInfo.mode,
                returnTravelIcon: returnTravelInfo.icon
              };
              
              // Updated last place with return travel time
            } catch (travelError) {
              console.error('Return travel time calculation failed:', travelError);
              Alert.alert(
                'Travel Time Error',
                `Could not calculate return travel time from ${placeWithTravelTime.name} to ${returnLoc.address}: ${travelError.message}`,
                [{ text: 'OK' }]
              );
              return; // Stop the replacement process
            }
          } else {
            console.warn('No return location found for calculating return travel time');
          }
        } catch (error) {
          console.warn('Failed to calculate return travel time:', error);
        }
      }
      
      if (currentItinerary && changingPlace.index < currentItinerary.places.length - 1) {
        try {
          const nextPlace = currentItinerary.places[changingPlace.index + 1];
          
          // Calculating travel time to next place
          
          try {
            const nextTravelInfo = await GoogleMapsService.getSmartTravelTime(
              placeWithTravelTime,
              nextPlace
            );
            
            updatedNextPlace = {
              ...nextPlace,
              travelTimeFromPrevious: nextTravelInfo.duration,
              travelMode: nextTravelInfo.mode,
              travelIcon: nextTravelInfo.icon
            };
            
            // Updated next place with travel time
          } catch (travelError) {
            console.error('Next place travel time calculation failed:', travelError);
            Alert.alert(
              'Travel Time Error',
              `Could not calculate travel time from ${placeWithTravelTime.name} to ${nextPlace.name}: ${travelError.message}`,
              [{ text: 'OK' }]
            );
            return; // Stop the replacement process
          }
        } catch (error) {
          console.warn('Failed to update travel time to next place:', error);
        }
      }
      
      // Replace the place in the itinerary and update subsequent travel times
      const updateItineraryState = async (prevState) => {
        let newState;
        if (isMultiDay(prevState)) {
          const updatedDailyItineraries = prevState.dailyItineraries.map(day => {
            if (day.day === activeDay) {
              const updatedPlaces = [...day.places];
              const updatedSchedule = [...day.schedule];
              
              // Replace in places array
              updatedPlaces[changingPlace.index] = placeWithTravelTime;
              
              // Update next place with new travel time if calculated
              if (updatedNextPlace && changingPlace.index < updatedPlaces.length - 1) {
                updatedPlaces[changingPlace.index + 1] = updatedNextPlace;
              }
              
              // Replace in schedule and update timing information
              const scheduleIndex = updatedSchedule.findIndex(
                s => s.place.place_id === changingPlace.place.place_id
              );
              if (scheduleIndex >= 0) {
                updatedSchedule[scheduleIndex] = {
                  ...updatedSchedule[scheduleIndex],
                  place: placeWithTravelTime,
                  visitDuration: placeWithTravelTime.estimatedVisitDuration,
                  travelTimeFromPrevious: placeWithTravelTime.travelTimeFromPrevious,
                  travelMode: placeWithTravelTime.travelMode,
                  travelIcon: placeWithTravelTime.travelIcon
                };
                
                // Updated schedule item for replaced place
                
                // Update schedule for next place if travel time was updated
                if (updatedNextPlace && changingPlace.index < updatedPlaces.length - 1 && scheduleIndex < updatedSchedule.length - 1) {
                  const nextScheduleItem = updatedSchedule[scheduleIndex + 1];
                  if (nextScheduleItem) {
                    updatedSchedule[scheduleIndex + 1] = {
                      ...nextScheduleItem,
                      place: updatedNextPlace,
                      travelTimeFromPrevious: updatedNextPlace.travelTimeFromPrevious,
                      travelMode: updatedNextPlace.travelMode,
                      travelIcon: updatedNextPlace.travelIcon
                    };
                    
                    // Updated schedule item for next place
                  }
                }
              }
              
              return { ...day, places: updatedPlaces, schedule: updatedSchedule };
            }
            return day;
          });
          newState = { ...prevState, dailyItineraries: updatedDailyItineraries };
        } else {
          const updatedPlaces = [...prevState.places];
          const updatedSchedule = [...prevState.schedule];
          
          // Replace in places array
          updatedPlaces[changingPlace.index] = placeWithTravelTime;
          
          // Update next place with new travel time if calculated
          if (updatedNextPlace && changingPlace.index < updatedPlaces.length - 1) {
            updatedPlaces[changingPlace.index + 1] = updatedNextPlace;
          }
          
          // Replace in schedule and update timing information
          const scheduleIndex = updatedSchedule.findIndex(
            s => s.place.place_id === changingPlace.place.place_id
          );
          if (scheduleIndex >= 0) {
            // Updated schedule item for replaced place
            updatedSchedule[scheduleIndex] = {
              ...updatedSchedule[scheduleIndex],
              place: placeWithTravelTime,
              visitDuration: placeWithTravelTime.estimatedVisitDuration,
              travelTimeFromPrevious: placeWithTravelTime.travelTimeFromPrevious,
              travelMode: placeWithTravelTime.travelMode,
              travelIcon: placeWithTravelTime.travelIcon
            };
            
            // Update schedule for next place if travel time was updated
            if (updatedNextPlace && changingPlace.index < updatedPlaces.length - 1 && scheduleIndex < updatedSchedule.length - 1) {
              const nextScheduleItem = updatedSchedule[scheduleIndex + 1];
              if (nextScheduleItem) {
                updatedSchedule[scheduleIndex + 1] = {
                  ...nextScheduleItem,
                  place: updatedNextPlace,
                  travelTimeFromPrevious: updatedNextPlace.travelTimeFromPrevious,
                  travelMode: updatedNextPlace.travelMode,
                  travelIcon: updatedNextPlace.travelIcon
                };
              }
            }
          }
          
          newState = { ...prevState, places: updatedPlaces, schedule: updatedSchedule };
        }

        // Update route waypoints to reflect new place sequence
        const updateRouteWaypoints = async (places) => {
          const waypoints = [];
          
          // Add starting location
          waypoints.push({
            latitude: startingLocation.coordinates.latitude,
            longitude: startingLocation.coordinates.longitude
          });
          
          // Add all places with safe coordinate extraction
          for (const place of places) {
            try {
              const coords = await extractCoordinates(place);
              // Only add valid Philadelphia-area coordinates
              if (coords.lat > 39 && coords.lat < 41 && coords.lng > -76 && coords.lng < -74) {
                waypoints.push({
                  latitude: coords.lat,
                  longitude: coords.lng
                });
                console.log('‚úÖ Added waypoint for', place.name, ':', coords);
              } else {
                console.warn('‚ö†Ô∏è Skipping invalid waypoint coordinates for', place.name, ':', coords);
              }
            } catch (error) {
              console.warn('‚ö†Ô∏è Could not get coordinates for waypoint:', place.name, error);
            }
          }
          
          // Add return location if different
          if (returnLocation) {
            waypoints.push({
              latitude: returnLocation.coordinates.latitude,
              longitude: returnLocation.coordinates.longitude
            });
          }
          
          return { waypoints };
        };

        // Update route for the correct itinerary type
        if (isMultiDay(newState)) {
          const updatedDailyItineraries = await Promise.all(
            newState.dailyItineraries.map(async day => {
              if (day.day === activeDay) {
                const newRoute = await updateRouteWaypoints(day.places);
                return { ...day, route: newRoute };
              }
              return day;
            })
          );
          newState = { ...newState, dailyItineraries: updatedDailyItineraries };
        } else {
          const newRoute = await updateRouteWaypoints(newState.places);
          newState = { ...newState, route: newRoute };
        }

        // Debug: Log the state being passed to UnifiedTravelCalculator
        // State before recalculation
        
        // Recalculate schedule with new place to update all timing information
        try {
          const recalculatedState = calculateUnifiedSchedule(newState, activeDay - 1);
          return recalculatedState || newState;
        } catch (error) {
          console.error('Error recalculating schedule after place replacement:', error);
          return newState;
        }
      };
      
      // Execute the async update
      const updatedState = await updateItineraryState(itineraryState);
      setItineraryState(updatedState);
      
      // Force map region update to show new place location
      try {
        console.log('üó∫Ô∏è Updating map region after place replacement...');
        const newRegion = await calculateMapRegion();
        setMapRegion(newRegion);
        console.log('‚úÖ Map region updated successfully');
      } catch (mapError) {
        console.warn('‚ö†Ô∏è Could not update map region after place replacement:', mapError);
      }
      
      setChangingPlace(null);
      
    } catch (error) {
      console.error('Error replacing place:', error);
      Alert.alert(
        'Error', 
        'Could not replace the place. Please try again.',
        [{ text: 'OK' }]
      );
    }
  };

  // Safely format duration to prevent NaN display
  const formatSafeDuration = (durationString: string | number): string => {
    try {
      if (typeof durationString === 'number') {
        if (isNaN(durationString)) return '0h 0m';
        const hours = Math.floor(durationString / 60);
        const minutes = Math.floor(durationString % 60);
        return hours > 0 ? `${hours}h ${minutes}m` : `${minutes}m`;
      }
      
      if (typeof durationString === 'string') {
        // Check for NaN in the string
        if (durationString.includes('NaN')) {
          return '0h 0m';
        }
        return durationString;
      }
      
      return '0h 0m';
    } catch (error) {
      console.warn('Error formatting duration:', error);
      return '0h 0m';
    }
  };

  // Helper function to parse duration strings (e.g., "2h 30m") to minutes
  const parseDurationToMinutes = (duration: string | number | undefined): number => {
    if (typeof duration === 'number') {
      return isNaN(duration) ? 0 : duration;
    }
    
    if (typeof duration === 'string') {
      try {
        // Parse formats like "2h 30m", "45m", "1h"
        const hourMatch = duration.match(/(\d+)h/);
        const minuteMatch = duration.match(/(\d+)m/);
        
        const hours = hourMatch ? parseInt(hourMatch[1], 10) : 0;
        const minutes = minuteMatch ? parseInt(minuteMatch[1], 10) : 0;
        
        return (hours * 60) + minutes;
      } catch (error) {
        console.warn('Error parsing duration string:', duration, error);
        return 0;
      }
    }
    
    return 0;
  };

  // Calculate actual total duration including all travel, visiting, and dining time
  const calculateActualTotalDuration = (): string => {
    try {
      // 1. Visiting time at attractions (from current schedule - includes place replacements)
      let visitingTimeMinutes = 0;
      currentItinerary.schedule.forEach(item => {
        visitingTimeMinutes += item.visitDuration || 0;
      });
      
      // 2. Actual travel time between places + return travel (from current schedule - includes place replacements)
      const actualTravelTimeMinutes = calculateActualTravelTime(); // Now includes return travel time

      // 3. Calculate total dining impact (dining time + extra travel from detours)
      let totalDiningImpactMinutes = 0;
      
      currentItinerary.schedule.forEach(item => {
        if (item.diningStops && Array.isArray(item.diningStops)) {
          item.diningStops.forEach(stop => {
            // Use total_stop_impact which includes dining time + all travel detours
            if (typeof stop.total_stop_impact === 'number' && !isNaN(stop.total_stop_impact)) {
              totalDiningImpactMinutes += stop.total_stop_impact;
            } else {
              // Fallback: dining duration + detour time
              const diningTime = typeof stop.dining_duration === 'number' && !isNaN(stop.dining_duration) ? stop.dining_duration : 0;
              const detourTime = typeof stop.detour_time === 'number' && !isNaN(stop.detour_time) ? stop.detour_time : 0;
              totalDiningImpactMinutes += diningTime + detourTime;
            }
          });
        }
      });

      // Total = Visiting + Actual Travel (includes return travel) + Dining Impact
      // Note: actualTravelTimeMinutes now includes return travel time and updated travel times from place replacements
      // Note: total_stop_impact already includes the extra travel time for detours
      
      const totalMinutes = visitingTimeMinutes + actualTravelTimeMinutes + totalDiningImpactMinutes;
      
      
      return formatSafeDuration(totalMinutes);
    } catch (error) {
      console.warn('Error calculating actual total duration:', error);
      return formatSafeDuration(currentItinerary.totalDuration || '0h 0m');
    }
  };

  // Calculate actual travel time from current schedule (includes place replacements)
  const calculateActualTravelTime = (): number => {
    try {
      // Calculate travel time from actual schedule items (updated with place replacements)
      let totalTravelMinutes = 0;
      
      currentItinerary.schedule.forEach(item => {
        // Add base travel time to this place
        const travelTime = item.travelTimeFromPrevious || 0;
        totalTravelMinutes += travelTime;
        
        // Add travel time from dining stop detours
        if (item.diningStops && Array.isArray(item.diningStops)) {
          item.diningStops.forEach(stop => {
            // Add only the extra travel time (detour), not dining time
            if (stop.travel_breakdown) {
              const travelTo = stop.travel_breakdown.travel_to_restaurant || 0;
              const travelFrom = stop.travel_breakdown.travel_from_restaurant || 0;
              totalTravelMinutes += travelTo + travelFrom;
            } else if (typeof stop.detour_time === 'number' && !isNaN(stop.detour_time)) {
              // Fallback to detour_time if travel_breakdown not available
              totalTravelMinutes += stop.detour_time;
            }
          });
        }
      });

      // Add return travel time from last place back to starting location
      const lastPlace = currentItinerary.places[currentItinerary.places.length - 1];
      let returnTravelTime = 0;
      
      if (lastPlace?.returnTravelTime) {
        // Use the calculated return travel time
        returnTravelTime = lastPlace.returnTravelTime;
      } else if (currentItinerary.travelBreakdown?.lastToReturn) {
        // Use original return travel time from travel breakdown
        returnTravelTime = currentItinerary.travelBreakdown.lastToReturn;
      } else {
        // Fallback to first place travel time (symmetric estimate)
        returnTravelTime = currentItinerary.schedule[0]?.travelTimeFromPrevious || 15;
      }
      totalTravelMinutes += returnTravelTime;

      return totalTravelMinutes;
    } catch (error) {
      console.warn('Error calculating actual travel time:', error);
      return parseDurationToMinutes(currentItinerary.travelTime);
    }
  };

  // Calculate combined travel time (driving + walking) using the same logic as breakdown
  const calculateCombinedTravelTime = (): number => {
    try {
      let walkingMinutes = 0;
      let drivingMinutes = 0;
      
      // Calculate walking time (same logic as breakdown)
      currentItinerary.schedule.forEach((item, index) => {
        const rideId = generateRideId(
          index === 0 ? 'start' : currentItinerary.schedule[index - 1]?.place?.name || 'unknown',
          item.place?.name || 'unknown',
          index
        );
        const selectedMode = travelModes[rideId] || 'driving';
        const segmentTravelOptions = travelOptions[rideId];
        
        if (segmentTravelOptions && segmentTravelOptions[selectedMode] && selectedMode === 'walking') {
          walkingMinutes += segmentTravelOptions[selectedMode].duration;
        }
      });
      
      // Add dining stop walking time
      currentItinerary.schedule.forEach(item => {
        if (item.diningStops && Array.isArray(item.diningStops)) {
          item.diningStops.forEach(stop => {
            if (stop.travel_breakdown) {
              if (stop.travel_breakdown.travel_to_mode === 'walking') {
                walkingMinutes += stop.travel_breakdown.travel_to_restaurant || 0;
              }
              if (stop.travel_breakdown.travel_from_mode === 'walking') {
                walkingMinutes += stop.travel_breakdown.travel_from_restaurant || 0;
              }
            }
          });
        }
      });
      
      // Add return travel walking time
      const lastPlace = currentItinerary.places[currentItinerary.places.length - 1];
      if (lastPlace) {
        const returnRideId = generateRideId(lastPlace.name, 'return', 999);
        const selectedReturnMode = travelModes[returnRideId] || 'driving';
        const returnTravelOptions = travelOptions[returnRideId];
        
        if (returnTravelOptions && returnTravelOptions[selectedReturnMode] && selectedReturnMode === 'walking') {
          walkingMinutes += returnTravelOptions[selectedReturnMode].duration;
        } else if (lastPlace?.returnTravelTime && selectedReturnMode === 'walking') {
          walkingMinutes += lastPlace.returnTravelTime;
        }
      }
      
      // Calculate driving time (same logic as breakdown)
      currentItinerary.schedule.forEach((item, index) => {
        const rideId = generateRideId(
          index === 0 ? 'start' : currentItinerary.schedule[index - 1]?.place?.name || 'unknown',
          item.place?.name || 'unknown',
          index
        );
        const selectedMode = travelModes[rideId] || 'driving';
        const segmentTravelOptions = travelOptions[rideId];
        
        if (segmentTravelOptions && segmentTravelOptions[selectedMode] && selectedMode === 'driving') {
          drivingMinutes += segmentTravelOptions[selectedMode].duration;
        } else if (!segmentTravelOptions) {
          // Fallback: use travelTimeFromPrevious and assume driving
          drivingMinutes += item.travelTimeFromPrevious || 0;
        }
      });
      
      // Add dining stop driving time
      currentItinerary.schedule.forEach(item => {
        if (item.diningStops && Array.isArray(item.diningStops)) {
          item.diningStops.forEach(stop => {
            if (stop.travel_breakdown) {
              if (stop.travel_breakdown.travel_to_mode === 'driving') {
                drivingMinutes += stop.travel_breakdown.travel_to_restaurant || 0;
              }
              if (stop.travel_breakdown.travel_from_mode === 'driving') {
                drivingMinutes += stop.travel_breakdown.travel_from_restaurant || 0;
              }
            }
          });
        }
      });
      
      // Add return travel driving time
      if (lastPlace) {
        const returnRideId = generateRideId(lastPlace.name, 'return', 999);
        const selectedReturnMode = travelModes[returnRideId] || 'driving';
        const returnTravelOptions = travelOptions[returnRideId];
        
        if (returnTravelOptions && returnTravelOptions[selectedReturnMode] && selectedReturnMode === 'driving') {
          drivingMinutes += returnTravelOptions[selectedReturnMode].duration;
        } else if (lastPlace?.returnTravelTime && selectedReturnMode === 'driving') {
          drivingMinutes += lastPlace.returnTravelTime;
        } else if (lastPlace?.returnTravelTime) {
          // If return travel time exists but mode is not specified, assume driving
          drivingMinutes += lastPlace.returnTravelTime;
        }
      }
      
      return walkingMinutes + drivingMinutes;
    } catch (error) {
      console.warn('Error calculating combined travel time:', error);
      return calculateActualTravelTime();
    }
  };

  // Calculate dining stop statistics
  const getDiningStopStats = () => {
    try {
      let totalDiningStops = 0;
      let totalDiningTime = 0;
      const mealTypeCounts: { [key: string]: number } = {};

      currentItinerary.schedule.forEach(item => {
        if (item.diningStops && Array.isArray(item.diningStops)) {
          item.diningStops.forEach(stop => {
            totalDiningStops++;
            
            // Add only pure dining time (not travel)
            if (typeof stop.dining_duration === 'number' && !isNaN(stop.dining_duration)) {
              totalDiningTime += stop.dining_duration;
            }
            
            // Count meal types
            if (stop.meal_type) {
              mealTypeCounts[stop.meal_type] = (mealTypeCounts[stop.meal_type] || 0) + 1;
            }
          });
        }
      });

      return {
        totalStops: totalDiningStops,
        totalTime: totalDiningTime,
        totalTimeMinutes: totalDiningTime, // Add this for the calculation
        mealTypes: mealTypeCounts,
        formattedTime: formatSafeDuration(totalDiningTime)
      };
    } catch (error) {
      console.warn('Error calculating dining stop stats:', error);
      return {
        totalStops: 0,
        totalTime: 0,
        totalTimeMinutes: 0,
        mealTypes: {},
        formattedTime: '0m'
      };
    }
  };

  // Handle dining stop removal
  const handleDiningStopRemove = () => {
    if (!editingDiningStop) return;

    console.log('üóëÔ∏è REMOVING DINING STOP:', JSON.stringify({
      itemIndex: editingDiningStop.itemIndex,
      stopIndex: editingDiningStop.stopIndex,
      currentSchedule: currentItinerary.schedule.map(item => ({
        place: item.place.name,
        arrival: item.arrivalTime,
        departure: item.departureTime,
        diningStops: item.diningStops?.length || 0
      }))
    }, null, 2));

    // Check if this is a return dining stop (itemIndex equals places.length)
    // Using memoized currentItinerary
    if (editingDiningStop.itemIndex === currentItinerary.places.length) {
      console.log('üóëÔ∏è Removing return dining stop from detail page');
      setEditingDiningStop(null); // Close the modal
      removeReturnDiningStop(); // Use special return dining stop removal
      return;
    }

    setItineraryState(prevState => {
      let newState;
      if (isMultiDay(prevState)) {
        const updatedDailyItineraries = prevState.dailyItineraries.map(day => {
          if (day.day === activeDay) {
            const updatedSchedule = day.schedule.map((item, index) => {
              if (index === editingDiningStop.itemIndex) {
                const updatedDiningStops = [...(item.diningStops || [])];
                updatedDiningStops.splice(editingDiningStop.stopIndex, 1);
                return { ...item, diningStops: updatedDiningStops };
              }
              return item;
            });
            return { ...day, schedule: updatedSchedule };
          }
          return day;
        });
        newState = { ...prevState, dailyItineraries: updatedDailyItineraries };
      } else {
        const updatedSchedule = prevState.schedule.map((item, index) => {
          if (index === editingDiningStop.itemIndex) {
            const updatedDiningStops = [...(item.diningStops || [])];
            updatedDiningStops.splice(editingDiningStop.stopIndex, 1);
            return { ...item, diningStops: updatedDiningStops };
          }
          return item;
        });
        newState = { ...prevState, schedule: updatedSchedule };
      }
      
      // CRITICAL FIX: Transfer dining stops from schedule to places before recalculation
      const stateWithDiningStops = { ...newState };
      
      if (isMultiDay(newState)) {
        const day = newState.dailyItineraries[activeDay - 1];
        if (day && day.schedule && day.places) {
          console.log('üçΩÔ∏è Transferring dining stops from schedule to places for multi-day itinerary after modal removal');
          const updatedPlaces = day.places.map((place: any, index: number) => {
            const scheduleItem = day.schedule[index];
            if (scheduleItem && scheduleItem.diningStops && scheduleItem.diningStops.length > 0) {
              console.log(`üçΩÔ∏è Found ${scheduleItem.diningStops.length} dining stops for place ${index} (${place.name}) after modal removal`);
              return { ...place, diningStops: scheduleItem.diningStops };
            }
            return { ...place, diningStops: [] }; // Clear dining stops if none in schedule
          });
          
          const updatedDay = { ...day, places: updatedPlaces };
          const updatedDailyItineraries = [...newState.dailyItineraries];
          updatedDailyItineraries[activeDay - 1] = updatedDay;
          stateWithDiningStops.dailyItineraries = updatedDailyItineraries;
        }
      } else {
        if (newState.schedule && newState.places) {
          console.log('üçΩÔ∏è Transferring dining stops from schedule to places for single-day itinerary after modal removal');
          const updatedPlaces = newState.places.map((place: any, index: number) => {
            const scheduleItem = newState.schedule[index];
            if (scheduleItem && scheduleItem.diningStops && scheduleItem.diningStops.length > 0) {
              console.log(`üçΩÔ∏è Found ${scheduleItem.diningStops.length} dining stops for place ${index} (${place.name}) after modal removal`);
              return { ...place, diningStops: scheduleItem.diningStops };
            }
            return { ...place, diningStops: [] }; // Clear dining stops if none in schedule
          });
          
          stateWithDiningStops.places = updatedPlaces;
        }
      }

      // Recalculate schedule
      try {
        const recalculatedState = calculateUnifiedSchedule(stateWithDiningStops, activeDay - 1);
        
        // Validate the recalculated state
        if (!recalculatedState || (isMultiDay(recalculatedState) && !recalculatedState.dailyItineraries) ||
            (!isMultiDay(recalculatedState) && !recalculatedState.schedule)) {
          console.warn('Invalid recalculated state during update, reverting to newState');
          return newState;
        }
        
        console.log('‚úÖ Dining stop removed from modal and schedule recalculated successfully');
        return recalculatedState;
      } catch (error) {
        console.error('Error recalculating schedule during update:', error);
        return newState;
      }
    });
    
    // Update route waypoints to remove the dining stop
    setTimeout(() => {
      updateRouteWaypoints();
    }, 100); // Small delay to ensure state update is processed

    setEditingDiningStop(null);
  };

  // Handle visit duration editing
  const handleVisitDurationPress = (scheduleIndex: number, currentDuration: number, placeName: string) => {
    setEditingVisitDuration({ scheduleIndex, currentDuration, placeName });
    setNewVisitDuration(currentDuration.toString());
  };

  const handleVisitDurationUpdate = () => {
    if (!editingVisitDuration) return;

    const duration = parseInt(newVisitDuration);
    if (isNaN(duration) || duration <= 0 || duration > 480) { // Max 8 hours
      Alert.alert('Invalid Duration', 'Please enter a valid duration between 1 and 480 minutes (8 hours).');
      return;
    }

    try {
      // Update the itinerary with new duration and recalculate schedule
      setItineraryState(prevState => {
        let updatedState;
        
        if (isMultiDay(prevState)) {
          // Handle multi-day itinerary
          const updatedDailyItineraries = [...prevState.dailyItineraries];
          const dayIndex = activeDay - 1;
          const currentDay = updatedDailyItineraries[dayIndex];
          
          if (currentDay) {
            // Update the specific day's schedule and places
            const updatedDaySchedule = [...currentDay.schedule];
            const updatedDayPlaces = [...currentDay.places];
            
            // Update schedule
            updatedDaySchedule[editingVisitDuration.scheduleIndex] = {
              ...updatedDaySchedule[editingVisitDuration.scheduleIndex],
              visitDuration: duration
            };
            
            // Update underlying place data
            if (updatedDayPlaces[editingVisitDuration.scheduleIndex]) {
              updatedDayPlaces[editingVisitDuration.scheduleIndex] = {
                ...updatedDayPlaces[editingVisitDuration.scheduleIndex],
                estimatedVisitDuration: duration
              };
              console.log(`‚úÖ Updated multi-day place ${editingVisitDuration.scheduleIndex} visit duration to ${duration} minutes`);
            }
            
            // Recalculate times for this day
            const updatedDay = {
              ...currentDay,
              places: updatedDayPlaces,
              schedule: updatedDaySchedule
            };
            
            updatedDailyItineraries[dayIndex] = updatedDay;
            updatedState = { ...prevState, dailyItineraries: updatedDailyItineraries };
          } else {
            updatedState = prevState;
          }
        } else {
          // Handle single-day itinerary
          const updatedItinerary = recalculateScheduleWithNewDuration(
            editingVisitDuration.scheduleIndex, 
            duration
          );
          updatedState = updatedItinerary;
        }
        
        return updatedState;
      });
      
      setEditingVisitDuration(null);
      setNewVisitDuration('');
    } catch (error) {
      console.error('Error updating visit duration:', error);
      Alert.alert('Error', 'Failed to update visit duration. Please try again.');
    }
  };

  const recalculateScheduleWithNewDuration = (scheduleIndex: number, newDuration: number) => {
    // Using memoized currentItinerary
    const updatedSchedule = [...currentItinerary.schedule];
    
    // Update the visit duration for the selected place
    updatedSchedule[scheduleIndex] = {
      ...updatedSchedule[scheduleIndex],
      visitDuration: newDuration
    };
    
    // CRITICAL FIX: Also update the underlying place data with the new visit duration
    // This ensures the change persists when calculateUnifiedSchedule is called later
    const updatedPlaces = [...currentItinerary.places];
    if (updatedPlaces[scheduleIndex]) {
      updatedPlaces[scheduleIndex] = {
        ...updatedPlaces[scheduleIndex],
        estimatedVisitDuration: newDuration
      };
      console.log(`‚úÖ Updated place ${scheduleIndex} (${updatedPlaces[scheduleIndex].name}) visit duration to ${newDuration} minutes`);
    }

    // Recalculate departure time for current place
    const currentItem = updatedSchedule[scheduleIndex];
    const arrivalTime = parseTime(currentItem.arrivalTime);
    const newDepartureTime = addMinutes(arrivalTime, newDuration);
    updatedSchedule[scheduleIndex].departureTime = formatTime(newDepartureTime);

    // Recalculate arrival and departure times for subsequent places
    for (let i = scheduleIndex + 1; i < updatedSchedule.length; i++) {
      const prevItem = updatedSchedule[i - 1];
      const nextItem = updatedSchedule[i];
      
      // Calculate travel time from previous place
      const travelTime = nextItem.place.travelTimeFromPrevious || 15;
      const prevDepartureTime = parseTime(prevItem.departureTime);
      const newArrivalTime = addMinutes(prevDepartureTime, travelTime);
      const nextDepartureTime = addMinutes(newArrivalTime, nextItem.visitDuration);
      
      updatedSchedule[i] = {
        ...nextItem,
        arrivalTime: formatTime(newArrivalTime),
        departureTime: formatTime(nextDepartureTime)
      };
    }

    // Update total visiting time and duration
    const totalVisitingTime = updatedSchedule.reduce((total, item) => total + item.visitDuration, 0);
    const totalTravelTime = currentItinerary.travelTime;
    const newTotalDuration = totalVisitingTime + totalTravelTime;

    return {
      ...currentItinerary,
      places: updatedPlaces,
      schedule: updatedSchedule,
      visitingTime: totalVisitingTime,
      totalDuration: newTotalDuration
    };
  };

  // Helper functions for time calculations
  const parseTime = (timeString: string): Date => {
    const [hours, minutes] = timeString.split(':').map(Number);
    const date = new Date();
    date.setHours(hours, minutes, 0, 0);
    return date;
  };

  const addMinutes = (date: Date, minutes: number): Date => {
    return new Date(date.getTime() + minutes * 60000);
  };

  const formatTime = (date: Date): string => {
    return date.toTimeString().slice(0, 5);
  };

  // Memoized current itinerary to prevent unnecessary recalculations
  const currentItinerary = React.useMemo((): GeneratedItinerary => {
    try {
      if (isMultiDay(itineraryState)) {
        const dailyItinerary = itineraryState.dailyItineraries?.find(day => day.day === activeDay);
        if (dailyItinerary) {
          // Convert DailyItinerary to GeneratedItinerary format
          return {
            places: dailyItinerary.places || [],
            visitingTime: dailyItinerary.visitingTime || '0h',
            travelTime: dailyItinerary.travelTime || '0h',
            totalDuration: dailyItinerary.totalDuration || '0h',
            travelBreakdown: dailyItinerary.travelBreakdown || [],
            route: dailyItinerary.route || [],
            schedule: dailyItinerary.schedule || [],
            uncoveredInterests: dailyItinerary.uncoveredInterests || [],
            optimizationNotes: dailyItinerary.optimizationNotes || []
          };
        }
        // Fallback to first day if active day not found
        const firstDay = itineraryState.dailyItineraries?.[0];
        if (firstDay) {
          return {
            places: firstDay.places || [],
            visitingTime: firstDay.visitingTime || '0h',
            travelTime: firstDay.travelTime || '0h',
            totalDuration: firstDay.totalDuration || '0h',
            travelBreakdown: firstDay.travelBreakdown || [],
            route: firstDay.route || [],
            schedule: firstDay.schedule || [],
            uncoveredInterests: firstDay.uncoveredInterests || [],
            optimizationNotes: firstDay.optimizationNotes || []
          };
        }
      }
      
      // Single day itinerary with safe fallbacks
      return {
        places: itineraryState.places || [],
        visitingTime: itineraryState.visitingTime || '0h',
        travelTime: itineraryState.travelTime || '0h',
        totalDuration: itineraryState.totalDuration || '0h',
        travelBreakdown: itineraryState.travelBreakdown || [],
        route: itineraryState.route || [],
        schedule: itineraryState.schedule || [],
        uncoveredInterests: itineraryState.uncoveredInterests || [],
        optimizationNotes: itineraryState.optimizationNotes || []
      };
    } catch (error) {
      console.warn('Error getting current itinerary:', error);
      // Return minimal valid structure
      return {
        places: [],
        visitingTime: '0h',
        travelTime: '0h',
        totalDuration: '0h',
        travelBreakdown: [],
        route: [],
        schedule: [],
        uncoveredInterests: [],
        optimizationNotes: []
      };
    }
  }, [itineraryState, activeDay]);

  // Calculate map region to include all markers (places + dining stops)
  const calculateMapRegion = async () => {
    const allCoordinates = [];
    
    // Add starting location
    allCoordinates.push(startingLocation.coordinates);
    
    // Add return location if different
    if (returnLocation) {
      allCoordinates.push(returnLocation.coordinates);
    }
    
    // Use memoized current itinerary
    
    // Add all places with safe coordinate extraction
    if (currentItinerary.places) {
      for (const place of currentItinerary.places) {
        try {
          const coords = await extractCoordinates(place);
          // Only add valid Philadelphia-area coordinates (avoid 0,0 or invalid coords)
          if (coords.lat > 39 && coords.lat < 41 && coords.lng > -76 && coords.lng < -74) {
            allCoordinates.push({ latitude: coords.lat, longitude: coords.lng });
          } else {
            console.warn('‚ö†Ô∏è Skipping invalid coordinates for map region:', place.name, coords);
          }
        } catch (error) {
          console.warn('‚ö†Ô∏è Could not get coordinates for map region:', place.name, error);
        }
      }
    }
    
    // Add all dining stops
    if (currentItinerary.schedule) {
      currentItinerary.schedule.forEach(scheduleItem => {
        scheduleItem.diningStops?.forEach(diningStop => {
          // Validate dining stop coordinates too
          if (diningStop.coordinates && 
              diningStop.coordinates.latitude > 39 && diningStop.coordinates.latitude < 41 &&
              diningStop.coordinates.longitude > -76 && diningStop.coordinates.longitude < -74) {
            allCoordinates.push(diningStop.coordinates);
          } else {
            console.warn('‚ö†Ô∏è Skipping invalid dining stop coordinates for map region:', diningStop.name);
          }
        });
      });
    }
    
    if (allCoordinates.length === 0) {
      // Fallback to current city
      const currentCity = DataService.getCurrentCity();
      const cityCenter = currentCity?.coordinates || PHILADELPHIA_CENTER;
      return {
        latitude: cityCenter.latitude,
        longitude: cityCenter.longitude,
        latitudeDelta: 0.1,
        longitudeDelta: 0.1,
      };
    }
    
    // Calculate bounds
    const latitudes = allCoordinates.map(coord => coord.latitude);
    const longitudes = allCoordinates.map(coord => coord.longitude);
    
    const minLat = Math.min(...latitudes);
    const maxLat = Math.max(...latitudes);
    const minLng = Math.min(...longitudes);
    const maxLng = Math.max(...longitudes);
    
    const centerLat = (minLat + maxLat) / 2;
    const centerLng = (minLng + maxLng) / 2;
    
    const latDelta = Math.max(maxLat - minLat, 0.01) * 1.2; // Add 20% padding
    const lngDelta = Math.max(maxLng - minLng, 0.01) * 1.2; // Add 20% padding
    
    return {
      latitude: centerLat,
      longitude: centerLng,
      latitudeDelta: latDelta,
      longitudeDelta: lngDelta,
    };
  };

  // Initialize and update map region
  useEffect(() => {
    const updateMapRegion = async () => {
      try {
        const newRegion = await calculateMapRegion();
        setMapRegion(newRegion);
      } catch (error) {
        console.warn('‚ö†Ô∏è Error updating map region, using fallback:', error);
        // Fallback to current city
        const currentCity = DataService.getCurrentCity();
        const cityCenter = currentCity?.coordinates || PHILADELPHIA_CENTER;
        setMapRegion({
          latitude: cityCenter.latitude,
          longitude: cityCenter.longitude,
          latitudeDelta: 0.1,
          longitudeDelta: 0.1,
        });
      }
    };
    
    updateMapRegion();
  }, [itineraryState, startingLocation, returnLocation, activeDay]);

  // Using memoized currentItinerary"

  const toggleHoursExpansion = (placeId: string) => {
    const newExpanded = new Set(expandedHours);
    if (newExpanded.has(placeId)) {
      newExpanded.delete(placeId);
    } else {
      newExpanded.add(placeId);
    }
    setExpandedHours(newExpanded);
  };
  
  // Get the date for the current day being displayed
  const getCurrentDate = (): string => {
    if (isMultiDay(itinerary)) {
      const dailyItinerary = itinerary.dailyItineraries.find(day => day.day === activeDay);
      return dailyItinerary?.date || formData.date;
    }
    return formData.date;
  };

  // Get day of week from date string in a timezone-safe way
  const getDayOfWeekSafe = (dateString: string): number => {
    const [year, month, day] = dateString.split('-').map(Number);
    const date = new Date(year, month - 1, day); // Local time, month 0-indexed
    return date.getDay(); // 0=Sunday, 1=Monday, etc.
  };

  // Simple working hours formatter - shows actual hours for the itinerary date
  const formatWorkingHours = (place: PlaceRecommendation) => {
    if (!place.opening_hours) {
      return null;
    }

    try {
      const currentDate = getCurrentDate();
      const todayIndex = getDayOfWeekSafe(currentDate);
      const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
      const dayKeys = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
      const shortDays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
      
      let todayHours = null;
      let weeklyHours: Array<{day: string; hours: string; isToday: boolean; isClosed: boolean}> = [];

      // Handle object format (JSON with day keys)
      if (typeof place.opening_hours === 'object' && !Array.isArray(place.opening_hours)) {
        const keys = Object.keys(place.opening_hours);
        
        // Try different key formats for today
        const possibleTodayKeys = [
          dayKeys[todayIndex],           // 'monday'
          dayNames[todayIndex].toLowerCase(), // 'monday'
          dayNames[todayIndex],          // 'Monday'
          shortDays[todayIndex].toLowerCase(), // 'mon'
          shortDays[todayIndex],         // 'Mon'
        ];
        
        for (const key of possibleTodayKeys) {
          if (place.opening_hours[key]) {
            todayHours = place.opening_hours[key];
            break;
          }
        }
        
        // Build weekly schedule
        for (let i = 0; i < 7; i++) {
          let dayHours = null;
          for (const keyFormat of [dayKeys[i], dayNames[i].toLowerCase(), dayNames[i], shortDays[i]]) {
            if (place.opening_hours[keyFormat]) {
              dayHours = place.opening_hours[keyFormat];
              break;
            }
          }
          
          if (dayHours) {
            if (typeof dayHours === 'object' && dayHours !== null && 'opens' in dayHours && 'closes' in dayHours) {
              let hoursText = '';
              if (dayHours.opens === 'Closed') {
                hoursText = 'Closed';
              } else {
                // Check for split hours (comma-separated times)
                if (dayHours.opens.includes(',') && dayHours.closes.includes(',')) {
                  const openTimes = dayHours.opens.split(',').map(t => t.trim());
                  const closeTimes = dayHours.closes.split(',').map(t => t.trim());
                  const periods = [];
                  
                  for (let j = 0; j < Math.min(openTimes.length, closeTimes.length); j++) {
                    periods.push(`${openTimes[j]} - ${closeTimes[j]}`);
                  }
                  
                  hoursText = periods.join(', ');
                  
                  // Add break information if available
                  if (dayHours.break) {
                    hoursText += ` (Break: ${dayHours.break})`;
                  }
                } else {
                  // Regular single-period hours
                  hoursText = `${dayHours.opens} - ${dayHours.closes}`;
                }
              }
              
              weeklyHours.push({
                day: shortDays[i],
                hours: hoursText,
                isToday: i === todayIndex,
                isClosed: dayHours.opens === 'Closed'
              });
            } else if (typeof dayHours === 'string') {
              weeklyHours.push({
                day: shortDays[i],
                hours: dayHours,
                isToday: i === todayIndex,
                isClosed: dayHours.toLowerCase().includes('closed')
              });
            }
          } else {
            weeklyHours.push({
              day: shortDays[i],
              hours: 'Not available',
              isToday: i === todayIndex,
              isClosed: true
            });
          }
        }
      }
      
      // Handle string format
      else if (typeof place.opening_hours === 'string') {
        todayHours = place.opening_hours;
      }
      
      // Handle array format
      else if (Array.isArray(place.opening_hours)) {
        // Try to find today's hours in the array
        const todayName = dayNames[todayIndex];
        for (const hours of place.opening_hours) {
          if (typeof hours === 'string' && hours.toLowerCase().includes(todayName.toLowerCase())) {
            todayHours = hours;
            break;
          }
        }
        
        // If not found, show first available
        if (!todayHours && place.opening_hours.length > 0) {
          todayHours = place.opening_hours[0];
        }
        
        // Build weekly from array
        weeklyHours = place.opening_hours.map((hours, index) => ({
          day: index < 7 ? shortDays[index] : `Day ${index + 1}`,
          hours: hours,
          isToday: false,
          isClosed: typeof hours === 'string' && hours.toLowerCase().includes('closed')
        }));
      }

      // Format today's hours for display
      let todayDisplay = 'Hours not available';
      let isOpen = false;
      
      if (todayHours) {
        if (typeof todayHours === 'object' && todayHours.opens && todayHours.closes) {
          if (todayHours.opens === 'Closed') {
            todayDisplay = 'Closed today';
            isOpen = false;
          } else {
            // Handle split hours in today's display
            if (todayHours.opens.includes(',') && todayHours.closes.includes(',')) {
              const openTimes = todayHours.opens.split(',').map(t => t.trim());
              const closeTimes = todayHours.closes.split(',').map(t => t.trim());
              const periods = [];
              
              for (let j = 0; j < Math.min(openTimes.length, closeTimes.length); j++) {
                periods.push(`${openTimes[j]} - ${closeTimes[j]}`);
              }
              
              todayDisplay = periods.join(', ');
              if (todayHours.break) {
                todayDisplay += ` (Break: ${todayHours.break})`;
              }
            } else {
              todayDisplay = `${todayHours.opens} - ${todayHours.closes}`;
            }
            isOpen = true;
          }
        } else if (typeof todayHours === 'string') {
          todayDisplay = todayHours;
          isOpen = !todayHours.toLowerCase().includes('closed');
        }
      }

      return {
        todayHours: todayDisplay,
        isOpen: isOpen,
        weeklyHours: weeklyHours.length > 0 ? weeklyHours : null,
        dayName: dayNames[todayIndex]
      };
      
    } catch (error) {
      console.warn('Error parsing opening hours:', error);
      const today = new Date();
      const todayIndex = today.getDay();
      const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
      
      return {
        todayHours: 'Hours not available',
        isOpen: false,
        weeklyHours: null,
        dayName: dayNames[todayIndex]
      };
    }
  };

  const renderTravelTimeBlock = (place: PlaceRecommendation, index: number) => {
    // Check if this specific place has dining stops before it
    // Dining stops are attached to the destination place, so we check the current place's dining stops
    const currentScheduleItem = currentItinerary.schedule[index];
    const hasDiningStopsBeforeThisPlace = currentScheduleItem?.diningStops && currentScheduleItem.diningStops.length > 0;

    // If there are dining stops before this place, don't show direct travel time 
    // (travel time is now handled by the dining stop segments)
    if (hasDiningStopsBeforeThisPlace) {
      return null;
    }

    // Skip showing travel time for the first place if there are no dining stops before it
    // (the starting point to first place travel will be handled elsewhere)
    if (index === 0 && !hasDiningStopsBeforeThisPlace) {
      return null;
    }

    // Get unified travel display information - generate the same rideId as used elsewhere
    const fromPlace = index === 0 ? 'start' : currentItinerary.places[index - 1].name;
    const toPlace = place.name;
    const rideId = generateRideId(fromPlace, toPlace, index);
    const selectedTravelMode = travelModes[rideId] || 'driving';
    const displayInfo = getTravelDisplayInfo(rideId, selectedTravelMode);
    
    // Use unified display service values
    const travelTime = displayInfo.duration || 15; // Fallback to 15 minutes
    const travelIcon = displayInfo.icon;
    const travelMode = displayInfo.mode;
    const travelDistance = TravelTimeDisplayService.formatDistance(displayInfo.distance);

    const previousPlaceName = currentItinerary.places[index - 1]?.name || `place ${index}`;
    const truncatedName = previousPlaceName.length > 25 
      ? `${previousPlaceName.slice(0, 25)}...` 
      : previousPlaceName;
    const fromText = `from ${truncatedName}`;

    // Final debug log before display
    // Final travel time before display
    const isRideBooked = rideBookings.some(ride => ride.id === rideId);
    const canBookRide = true; // Always allow ride booking for driving mode

    const handleTravelIndicatorPress = () => {
      if (!canBookRide) return;
      
      setSelectedRideSegment({
        fromLocation: index === 0 ? startingLocation.address : currentItinerary.places[index - 1].address,
        toLocation: place.address,
        fromCoordinates: index === 0 ? startingLocation.coordinates : currentItinerary.places[index - 1].coordinates,
        toCoordinates: place.coordinates,
        distance: place.distanceFromPrevious ? place.distanceFromPrevious * 1000 : 1000,
        estimatedDuration: displayInfo.duration,
        rideId: rideId,
        scheduledTime: currentItinerary.schedule[index]?.arrivalTime,
      });
      setShowRideModal(true);
    };

    // Calculate travel options if not already calculated (moved to component level)
    // This will be handled by the main travel options calculation useEffect

    // Get travel mode options for dual indicator decision
    const modeOptions = getTravelModeOptions(rideId, selectedTravelMode);
    const segmentTravelOptions = travelOptions[rideId];
    
    // Show DualTravelIndicator if:
    // 1. Walking time is reasonable (‚â§ 25 minutes), OR
    // 2. Driving time is >= 1 minute (to allow driving service activation for short drives)
    const walkingOption = modeOptions.find(opt => opt.mode === 'walking');
    const drivingOption = modeOptions.find(opt => opt.mode === 'driving');
    const shouldShowDualIndicator = segmentTravelOptions && (
      (walkingOption && walkingOption.duration <= 25) ||
      (drivingOption && drivingOption.duration >= 1)
    );
    
    // DEBUG: Log DualTravelIndicator decision
    console.log(`üîç DualTravelIndicator decision for ${rideId}:`, {
      hasSegmentOptions: !!segmentTravelOptions,
      walkingDuration: walkingOption?.duration,
      drivingDuration: drivingOption?.duration,
      walkingEligible: walkingOption && walkingOption.duration <= 25,
      drivingEligible: drivingOption && drivingOption.duration >= 1,
      shouldShow: shouldShowDualIndicator,
      selectedMode: selectedTravelMode
    });

    return (
      <View>
        <View style={styles.compactTravelRow}>
          {shouldShowDualIndicator ? (
            <DualTravelIndicator
              travelOptions={segmentTravelOptions}
              selectedMode={selectedTravelMode}
              onModeChange={(mode) => handleTravelModeChange(rideId, mode)}
              onRideBookPress={handleTravelIndicatorPress}
              isRideBooked={isRideBooked}
              canBookRide={selectedTravelMode === 'driving'}
              scheduledTime={currentItinerary.schedule[index]?.arrivalTime}
              day={isMultiDay ? activeDay : undefined}
            />
          ) : (
            <TravelIndicator
              travelTime={displayInfo.duration}
              travelIcon={displayInfo.icon}
              fromLocation={index === 0 ? startingLocation.address : currentItinerary.places[index - 1].address}
              toLocation={place.address}
              fromCoordinates={index === 0 ? startingLocation.coordinates : currentItinerary.places[index - 1].coordinates}
              toCoordinates={place.coordinates}
              distance={displayInfo.distance}
              rideId={rideId}
              onPress={handleTravelIndicatorPress}
              isRideBooked={isRideBooked}
              canBookRide={canBookRide}
              scheduledTime={currentItinerary.schedule[index]?.arrivalTime}
              day={isMultiDay ? activeDay : undefined}
            />
          )}
          <TouchableOpacity 
            style={styles.circularAddFoodButton}
            onPress={() => handleDiningStopPress(index - 1, index)}
            activeOpacity={0.7}
          >
            <Text style={styles.circularAddFoodIcon}>+</Text>
          </TouchableOpacity>
        </View>
      </View>
    );
  };

  // Booking handlers
  const handleTicketSelect = (booking: TicketBooking | null, placeId?: string) => {
    setTicketBookings(prev => {
      if (booking === null && placeId) {
        // Handle unselect - remove all bookings for this place
        return prev.filter(ticket => ticket.placeId !== placeId);
      }
      
      if (!booking) return prev;
      
      const existingIndex = prev.findIndex(ticket => ticket.placeId === booking.placeId);
      if (existingIndex >= 0) {
        const updated = [...prev];
        updated[existingIndex] = booking;
        return updated;
      } else {
        return [...prev, booking];
      }
    });
  };

  const handleRideSelect = (booking: RideBooking) => {
    setRideBookings(prev => {
      const existingIndex = prev.findIndex(ride => ride.id === booking.id);
      if (existingIndex >= 0) {
        const updated = [...prev];
        updated[existingIndex] = booking;
        return updated;
      } else {
        return [...prev, booking];
      }
    });
  };

  const handleRideRemove = (rideId: string) => {
    setRideBookings(prev => prev.filter(ride => ride.id !== rideId));
  };

  // Calculate both walking and driving times for a travel segment
  const calculateTravelOptions = async (
    rideId: string,
    fromLocation: string,
    toLocation: string,
    fromCoordinates: { latitude: number; longitude: number },
    toCoordinates: { latitude: number; longitude: number }
  ): Promise<TravelOptions | null> => {
    try {
      const origin = `${fromCoordinates.latitude},${fromCoordinates.longitude}`;
      const destination = `${toCoordinates.latitude},${toCoordinates.longitude}`;


      // Calculate driving time using Google Maps API
      const drivingResult = await GoogleMapsService.getPreciseTravelTime(origin, destination, 'driving');
      console.log(`üöó Driving: ${drivingResult.duration} min, ${drivingResult.distance}m`);
      
      // Calculate walking time using Google Maps API
      const walkingResult = await GoogleMapsService.getPreciseTravelTime(origin, destination, 'walking');
      console.log(`üö∂ Walking: ${walkingResult.duration} min, ${walkingResult.distance}m`);

      const travelOptions: TravelOptions = {
        driving: {
          duration: drivingResult.duration,
          distance: drivingResult.distance,
          icon: drivingResult.icon,
        },
        walking: {
          duration: walkingResult.duration,
          distance: walkingResult.distance,
          icon: walkingResult.icon,
        },
        rideId,
        fromLocation,
        toLocation,
        fromCoordinates,
        toCoordinates,
      };

      // Verify we got different results for walking vs driving
      if (drivingResult.duration === walkingResult.duration) {
        console.warn(`‚ö†Ô∏è Suspicious: Same duration for walking and driving (${drivingResult.duration} min)`);
      }

      const walkingRatio = walkingResult.duration / drivingResult.duration;
      console.log(`üìä Walking/Driving ratio: ${walkingRatio.toFixed(2)}x (${walkingResult.duration}/${drivingResult.duration})`);

      if (walkingRatio < 1.5) {
        console.warn(`‚ö†Ô∏è Walking time suspiciously close to driving time (ratio: ${walkingRatio.toFixed(2)})`);
      }

      // Determine smart default mode based on walking vs driving times
      let defaultMode: 'driving' | 'walking' = 'driving';
      
      if (walkingResult.duration < drivingResult.duration) {
        // Walking is faster than driving (traffic, parking, etc.)
        defaultMode = 'walking';
        console.log(`üö∂ Smart default: Walking is faster (${walkingResult.duration} < ${drivingResult.duration} min)`);
      } else if (walkingResult.duration <= 5) {
        // Walking is very short (‚â§ 5 minutes)
        defaultMode = 'walking';
        console.log(`üö∂ Smart default: Walking is very short (${walkingResult.duration} ‚â§ 5 min)`);
      } else {
        console.log(`üöó Smart default: Driving recommended (walking ${walkingResult.duration} min, driving ${drivingResult.duration} min)`);
      }

      // Set the default mode if not already set
      const isNewDefault = !travelModes[rideId];
      const finalMode = travelModes[rideId] || defaultMode;
      
      setTravelModes(prev => ({
        ...prev,
        [rideId]: finalMode
      }));

      // Store the travel options first
      console.log(`üíæ STORING travel options for rideId: ${rideId}`, {
        walking: travelOptions.walking.duration,
        driving: travelOptions.driving.duration,
        fromLocation,
        toLocation
      });
      
      setTravelOptions(prev => {
        const updatedOptions = {
          ...prev,
          [rideId]: travelOptions
        };
        
        // CRITICAL FIX: Don't trigger immediate recalculation to preserve first place arrival time fix
        // The schedule will be recalculated when all travel options are available
        console.log(`üíæ Stored travel options for ${rideId} - delaying recalculation to preserve first place arrival time fix`);
        
        return updatedOptions;
      });

      // If we're setting walking as default and it's different from what the itinerary was generated with,
      // we need to recalculate the schedule to use walking times
      if (isNewDefault && finalMode === 'walking') {
        
        // Store the travel options we just calculated for direct use
        const justCalculatedOptions = travelOptions;
        
        // CRITICAL FIX: Don't trigger immediate recalculation to preserve first place arrival time fix
        console.log(`üíæ Walking mode set as default for ${rideId} - delaying recalculation to preserve first place arrival time fix`);
      }

      return travelOptions;
    } catch (error) {
      console.warn('‚ö†Ô∏è Primary travel calculation failed (trying fallbacks):', error.message || error);
      
      // NEW FIX: Try using place names with Google Maps API as fallback
      console.log('üîÑ Activating fallback system (normal behavior):', { rideId, fromLocation, toLocation });
      
      try {
        // Use the same method as itinerary generation - Google Maps API with place names
        const drivingResult = await GoogleMapsService.getTravelTimeByNames(
          fromLocation,
          toLocation,
          'Philadelphia, PA'
        );
        console.log(`‚úÖ Place name fallback success: ${drivingResult.duration} min driving`);
        
        // Calculate walking time as well
        const walkingResult = await GoogleMapsService.getPreciseTravelTime(
          `${fromLocation}, Philadelphia, PA`,
          `${toLocation}, Philadelphia, PA`,
          'walking'
        );
        
        const travelOptions: TravelOptions = {
          driving: {
            duration: drivingResult.duration,
            distance: drivingResult.distance,
            icon: drivingResult.icon,
          },
          walking: {
            duration: walkingResult.duration,
            distance: walkingResult.distance,
            icon: walkingResult.icon,
          },
          rideId,
          fromLocation,
          toLocation,
          fromCoordinates,
          toCoordinates,
        };
        
        console.log('‚úÖ Place name-based travel options created:', {
          rideId,
          driving: `${drivingResult.duration} min`,
          walking: `${walkingResult.duration} min`
        });
        
        // Set default mode
        const defaultMode = walkingResult.duration <= 15 ? 'walking' : 'driving';
        
        setTravelModes(prev => ({
          ...prev,
          [rideId]: travelModes[rideId] || defaultMode
        }));
        
        setTravelOptions(prev => ({
          ...prev,
          [rideId]: travelOptions
        }));
        
        // CRITICAL FIX: Don't trigger immediate recalculation to preserve first place arrival time fix
        console.log(`üíæ Place name fallback completed for ${rideId} - delaying recalculation to preserve first place arrival time fix`);
        
        return travelOptions;
        
      } catch (fallbackError) {
        console.error('üö® Place name fallback also failed:', fallbackError.message || fallbackError);
        
        // Last resort: Use GoogleMapsService coordinate-based fallback (more robust)
        console.log('üîÑ Using GoogleMapsService coordinate fallback for:', { rideId, fromLocation, toLocation });
        
        try {
          // Use the more robust fallback from GoogleMapsService
          const fallbackMatrix = await GoogleMapsService.getDistanceMatrix(
            [`${fromCoordinates.latitude},${fromCoordinates.longitude}`],
            [`${toCoordinates.latitude},${toCoordinates.longitude}`],
            'driving'
          );
          
          if (fallbackMatrix && fallbackMatrix.length > 0 && fallbackMatrix[0].length > 0) {
            const drivingData = fallbackMatrix[0][0];
            const walkingMatrix = await GoogleMapsService.getDistanceMatrix(
              [`${fromCoordinates.latitude},${fromCoordinates.longitude}`],
              [`${toCoordinates.latitude},${toCoordinates.longitude}`],
              'walking'
            );
            const walkingData = walkingMatrix[0][0];
            
            const fallbackOptions: TravelOptions = {
              driving: {
                duration: Math.round(drivingData.duration / 60), // Convert seconds to minutes
                distance: drivingData.distance,
                icon: 'üöó',
              },
              walking: {
                duration: Math.round(walkingData.duration / 60), // Convert seconds to minutes
                distance: walkingData.distance,
                icon: 'üö∂',
              },
              rideId,
              fromLocation,
              toLocation,
              fromCoordinates,
              toCoordinates,
            };
            
            console.log('‚úÖ GoogleMapsService fallback created:', {
              rideId,
              driving: `${fallbackOptions.driving.duration} min`,
              walking: `${fallbackOptions.walking.duration} min`
            });
            
            const defaultMode = fallbackOptions.walking.duration <= 15 ? 'walking' : 'driving';
            
            setTravelModes(prev => ({
              ...prev,
              [rideId]: travelModes[rideId] || defaultMode
            }));
            
            setTravelOptions(prev => ({
              ...prev,
              [rideId]: fallbackOptions
            }));
            
            // CRITICAL FIX: Don't trigger immediate recalculation to preserve first place arrival time fix
            console.log(`üíæ GoogleMapsService fallback completed for ${rideId} - delaying recalculation to preserve first place arrival time fix`);
            
            return fallbackOptions;
          }
        } catch (finalError) {
          console.error('üö® GoogleMapsService fallback also failed:', finalError.message || finalError);
        }
        
        // Ultimate fallback: Return null and let the UI handle it
        Alert.alert(
          'Travel Time Calculation Failed',
          `Could not calculate travel time between ${fromLocation} and ${toLocation}. All methods failed.`,
          [{ text: 'OK' }]
        );
        return null;
      }
    }
  };

  // Handle travel mode change (walking/driving)
  const handleTravelModeChange = (rideId: string, newMode: 'driving' | 'walking') => {
    // Get the current mode before updating state (smart default will be set by calculateTravelOptions)
    const currentMode = travelModes[rideId] || 'driving';
    
    // Only proceed if the mode is actually changing
    if (currentMode === newMode) return;
    
    console.log(`üîÑ Travel mode changing for ${rideId}: ${currentMode} ‚Üí ${newMode}`);
    
    // Get the travel options for this segment to show exact time difference
    const options = travelOptions[rideId];
    if (options) {
      const newTravelTime = options[newMode].duration;
      const oldTravelTime = options[currentMode].duration;
      console.log(`‚è±Ô∏è Travel time changing: ${oldTravelTime}min ‚Üí ${newTravelTime}min`);
    }
    
    // Update travel mode state and immediately trigger recalculation with the new mode
    const updatedModes = {
      ...travelModes,
      [rideId]: newMode
    };
    
    setTravelModes(updatedModes);
    
    // Immediately recalculate with the updated travel modes
    setTimeout(() => {
      console.log(`üîÑ Recalculating schedule with updated mode: ${rideId} = ${newMode}`);
      const recalculatedItinerary = calculateUnifiedSchedule(
        itineraryState,
        isMultiDay(itineraryState) ? activeDay - 1 : undefined,
        travelOptions, // Current travel options
        updatedModes   // Updated travel modes
      );
      setItineraryState(recalculatedItinerary);
    }, 50);
  };

  // Handle dining stop travel mode change
  const handleDiningStopTravelModeChange = (rideId: string, newMode: 'driving' | 'walking', diningStopIndex: number, itemIndex: number, travelDirection: 'to' | 'from') => {
    console.log(`üçΩÔ∏è Dining stop travel mode changing: ${rideId} ‚Üí ${newMode} (${travelDirection})`);
    console.log(`üçΩÔ∏è Dining stop params:`, { rideId, newMode, diningStopIndex, itemIndex, travelDirection });
    console.log(`üçΩÔ∏è Current travelModes state:`, travelModes);
    
    // Get the current mode before updating state
    const currentMode = travelModes[rideId] || 'driving';
    
    // Only proceed if the mode is actually changing
    if (currentMode === newMode) return;
    
    console.log(`üîÑ Dining stop travel mode changing for ${rideId}: ${currentMode} ‚Üí ${newMode}`);
    
    // Update travel mode state exactly like regular travel mode changes
    const updatedModes = {
      ...travelModes,
      [rideId]: newMode
    };
    
    setTravelModes(updatedModes);
    
    // CRITICAL FIX: Update the dining stop's travel_breakdown properties for UI display
    // This ensures the UI shows the correct selected mode and icon
    setItineraryState(prevState => {
      try {
        let updatedState;
        
        if (isMultiDay(prevState)) {
          const updatedDailyItineraries = prevState.dailyItineraries.map(day => {
            if (day.day === activeDay) {
              const updatedSchedule = day.schedule.map((item, index) => {
                if (index === itemIndex && item.diningStops && item.diningStops[diningStopIndex]) {
                  const updatedDiningStops = [...item.diningStops];
                  const diningStop = { ...updatedDiningStops[diningStopIndex] };
                  
                  // Update the travel_breakdown properties for UI display
                  if (diningStop.travel_breakdown) {
                    diningStop.travel_breakdown = {
                      ...diningStop.travel_breakdown,
                      [`travel_${travelDirection}_mode`]: newMode,
                      [`travel_${travelDirection}_icon`]: newMode === 'walking' ? 'üö∂' : 'üöó'
                    };
                  }
                  
                  updatedDiningStops[diningStopIndex] = diningStop;
                  return { ...item, diningStops: updatedDiningStops };
                }
                return item;
              });
              return { ...day, schedule: updatedSchedule };
            }
            return day;
          });
          updatedState = { ...prevState, dailyItineraries: updatedDailyItineraries };
        } else {
          const updatedSchedule = prevState.schedule.map((item, index) => {
            if (index === itemIndex && item.diningStops && item.diningStops[diningStopIndex]) {
              const updatedDiningStops = [...item.diningStops];
              const diningStop = { ...updatedDiningStops[diningStopIndex] };
              
              // Update the travel_breakdown properties for UI display
              if (diningStop.travel_breakdown) {
                diningStop.travel_breakdown = {
                  ...diningStop.travel_breakdown,
                  [`travel_${travelDirection}_mode`]: newMode,
                  [`travel_${travelDirection}_icon`]: newMode === 'walking' ? 'üö∂' : 'üöó'
                };
              }
              
              updatedDiningStops[diningStopIndex] = diningStop;
              return { ...item, diningStops: updatedDiningStops };
            }
            return item;
          });
          updatedState = { ...prevState, schedule: updatedSchedule };
        }
        
        console.log(`üçΩÔ∏è Dining stop travel mode updated for UI: ${travelDirection} = ${newMode}`);
        return updatedState;
      } catch (error) {
        console.error('Error updating dining stop travel mode for UI:', error);
        return prevState;
      }
    });
    
    // CRITICAL FIX: Trigger full schedule recalculation exactly like regular travel mode changes
    // This ensures that dining stop travel mode changes work exactly like regular place travel mode changes
    setTimeout(() => {
      console.log(`üîÑ Recalculating schedule for dining stop travel mode change: ${rideId} = ${newMode}`);
      const recalculatedItinerary = calculateUnifiedSchedule(
        itineraryState,
        isMultiDay(itineraryState) ? activeDay - 1 : undefined,
        travelOptions, // Current travel options
        updatedModes   // Updated travel modes
      );
      setItineraryState(recalculatedItinerary);
    }, 50);
  };

  // Simplified schedule recalculation that doesn't require travel options lookup
  // Simplified: just trigger full recalculation using the UnifiedTravelCalculator
  const recalculateScheduleWithDirectTime = (changedRideId: string, newMode: 'driving' | 'walking', previousMode: 'driving' | 'walking', newTravelTime: number, timeDifference: number) => {
    console.log(`üîÑ Direct time recalculation for ${changedRideId}: ${previousMode} ‚Üí ${newMode}`);
    
    // Update travel mode and trigger full recalculation
    setTravelModes(prev => {
      const updatedModes = {
        ...prev,
        [changedRideId]: newMode
      };
      
      // Trigger recalculation with the updated travel modes
      setTimeout(() => {
        console.log(`üîÑ Direct recalculation with updated travel mode: ${changedRideId} = ${newMode}`);
        setTravelModes(updatedModes); // Update travel modes first
        setItineraryState(currentState => {
          return calculateUnifiedSchedule(
            currentState, 
            isMultiDay(currentState) ? activeDay - 1 : undefined,
            travelOptions, // Pass current travel options
            updatedModes // Pass updated modes directly
          );
        });
      }, 50);
      
      return updatedModes;
    });
  };

  // Simplified schedule recalculation when travel mode changes
  // Just trigger full recalculation using the UnifiedTravelCalculator
  const recalculateScheduleTimes = (changedRideId: string, newMode: 'driving' | 'walking', previousMode: 'driving' | 'walking') => {
    console.log(`üîÑ Travel mode changed for ${changedRideId}: ${previousMode} ‚Üí ${newMode}`);
    
    // Update travel mode in state first, then trigger full recalculation
    setTravelModes(prev => {
      const updatedModes = {
        ...prev,
        [changedRideId]: newMode
      };
      
      // Trigger recalculation with the updated travel modes
      setTimeout(() => {
        console.log(`üîÑ Recalculating schedule with updated travel mode: ${changedRideId} = ${newMode}`);
        setTravelModes(updatedModes); // Update travel modes first
        setItineraryState(currentState => {
          return calculateUnifiedSchedule(
            currentState, 
            isMultiDay(currentState) ? activeDay - 1 : undefined,
            travelOptions, // Pass current travel options
            updatedModes // Pass updated modes directly
          );
        });
      }, 50);
      
      return updatedModes;
    });
  };


  // Helper function to add minutes to time string
  const addMinutesToTime = (timeString: string, minutes: number): string => {
    const intMinutes = Math.round(minutes);
    const [hours, mins] = timeString.split(':').map(Number);
    const totalMinutes = hours * 60 + mins + intMinutes;
    const newHours = Math.floor(totalMinutes / 60);
    const newMins = totalMinutes % 60;
    return `${newHours.toString().padStart(2, '0')}:${newMins.toString().padStart(2, '0')}`;
  };

  // Unified travel calculation using new system
  const calculateUnifiedSchedule = (state: any, dayIndex?: number, overrideTravelOptions?: Record<string, any>, overrideTravelModes?: Record<string, any>) => {
    try {
      // Get start time - use startTime from itinerary if available, otherwise from schedule
      const startTime = state.startTime || state.schedule?.[0]?.arrivalTime || '09:00';
      
      // Use override options if provided, otherwise use component state
      const finalTravelOptions = overrideTravelOptions || travelOptions;
      const finalTravelModes = overrideTravelModes || travelModes;
      
      console.log('üîß UnifiedSchedule calculation input:', {
        startTime,
        availableTravelOptionsCount: Object.keys(finalTravelOptions).length,
        selectedTravelModesCount: Object.keys(finalTravelModes).length,
        placesCount: state.places?.length || 0,
        dayIndex,
        hasOverrideOptions: !!overrideTravelOptions,
        hasOverrideModes: !!overrideTravelModes,
        travelOptionKeys: Object.keys(finalTravelOptions).slice(0, 3), // Show first 3 keys for debugging
        travelModeKeys: Object.keys(finalTravelModes).slice(0, 3) // Show first 3 keys for debugging
      });
      
      // CRITICAL FIX: Transfer dining stops from schedule back to places before recalculation
      const stateWithDiningStops = { ...state };
      
      if (isMultiDay(state) && dayIndex !== undefined) {
        const day = state.dailyItineraries[dayIndex];
        if (day && day.schedule && day.places) {
          console.log('üçΩÔ∏è Transferring dining stops AND visit duration from schedule to places for multi-day itinerary');
          const updatedPlaces = day.places.map((place: any, index: number) => {
            const scheduleItem = day.schedule[index];
            if (scheduleItem) {
              const updatedPlace = { ...place };
              
              // Transfer dining stops
              if (scheduleItem.diningStops && scheduleItem.diningStops.length > 0) {
                console.log(`üçΩÔ∏è Found ${scheduleItem.diningStops.length} dining stops for place ${index} (${place.name})`);
                updatedPlace.diningStops = scheduleItem.diningStops;
              }
              
              // CRITICAL FIX: Transfer visit duration from schedule to place
              if (scheduleItem.visitDuration && scheduleItem.visitDuration !== place.estimatedVisitDuration) {
                console.log(`üìä Transferring visit duration from schedule to place ${index} (${place.name}): ${scheduleItem.visitDuration} minutes`);
                updatedPlace.estimatedVisitDuration = scheduleItem.visitDuration;
              }
              
              return updatedPlace;
            }
            return place;
          });
          
          const updatedDay = { ...day, places: updatedPlaces };
          const updatedDailyItineraries = [...state.dailyItineraries];
          updatedDailyItineraries[dayIndex] = updatedDay;
          stateWithDiningStops.dailyItineraries = updatedDailyItineraries;
        }
      } else if (state.schedule && state.places) {
        console.log('üçΩÔ∏è Transferring dining stops AND visit duration from schedule to places for single-day itinerary');
        const updatedPlaces = state.places.map((place: any, index: number) => {
          const scheduleItem = state.schedule[index];
          if (scheduleItem) {
            const updatedPlace = { ...place };
            
            // Transfer dining stops
            if (scheduleItem.diningStops && scheduleItem.diningStops.length > 0) {
              console.log(`üçΩÔ∏è Found ${scheduleItem.diningStops.length} dining stops for place ${index} (${place.name})`);
              updatedPlace.diningStops = scheduleItem.diningStops;
            }
            
            // CRITICAL FIX: Transfer visit duration from schedule to place
            if (scheduleItem.visitDuration && scheduleItem.visitDuration !== place.estimatedVisitDuration) {
              console.log(`üìä Transferring visit duration from schedule to place ${index} (${place.name}): ${scheduleItem.visitDuration} minutes`);
              updatedPlace.estimatedVisitDuration = scheduleItem.visitDuration;
            }
            
            return updatedPlace;
          }
          return place;
        });
        stateWithDiningStops.places = updatedPlaces;
      }
      
      const options = {
        startTime,
        availableTravelOptions: finalTravelOptions,
        selectedTravelModes: finalTravelModes,
        enableDebugLogging: true
      };
      
      const result = UnifiedTravelCalculator.calculateCompleteSchedule(
        stateWithDiningStops,
        options,
        dayIndex
      );
      
      console.log('‚úÖ Schedule recalculated successfully using UnifiedTravelCalculator', {
        scheduledPlaces: result.schedule?.length || 0,
        firstPlaceArrival: result.schedule?.[0]?.arrivalTime,
        secondPlaceArrival: result.schedule?.[1]?.arrivalTime,
        resultType: 'dailyItineraries' in result ? 'multi-day' : 'single-day'
      });
      
      // CRITICAL FIX: Transfer updated dining stops (with recalculated times) back to places
      // This ensures that UI displays the correct dining stop arrival/departure times
      const resultWithUpdatedDiningStops = { ...result };
      
      if (isMultiDay(result) && dayIndex !== undefined) {
        const day = result.dailyItineraries[dayIndex];
        if (day && day.schedule && day.places) {
          console.log('üçΩÔ∏è Transferring updated dining stop times back to places for multi-day itinerary');
          const updatedPlaces = day.places.map((place: any, index: number) => {
            const scheduleItem = day.schedule[index];
            if (scheduleItem && scheduleItem.diningStops && scheduleItem.diningStops.length > 0) {
              console.log(`üçΩÔ∏è Updating dining stop times for place ${index} (${place.name})`);
              return { ...place, diningStops: scheduleItem.diningStops };
            }
            return place;
          });
          
          const updatedDay = { ...day, places: updatedPlaces };
          const updatedDailyItineraries = [...result.dailyItineraries];
          updatedDailyItineraries[dayIndex] = updatedDay;
          resultWithUpdatedDiningStops.dailyItineraries = updatedDailyItineraries;
        }
      } else if (result.schedule && result.places) {
        console.log('üçΩÔ∏è Transferring updated dining stop times back to places for single-day itinerary');
        const updatedPlaces = result.places.map((place: any, index: number) => {
          const scheduleItem = result.schedule[index];
          if (scheduleItem && scheduleItem.diningStops && scheduleItem.diningStops.length > 0) {
            console.log(`üçΩÔ∏è Updating dining stop times for place ${index} (${place.name})`);
            return { ...place, diningStops: scheduleItem.diningStops };
          }
          return place;
        });
        resultWithUpdatedDiningStops.places = updatedPlaces;
      }
      
      return resultWithUpdatedDiningStops;
    } catch (error) {
      console.error('‚ùå UnifiedTravelCalculator error:', error);
      return state; // Return original state on failure
    }
  };

  // Get unified travel display information
  const getTravelDisplayInfo = (segmentId: string, selectedMode: 'driving' | 'walking') => {
    return TravelTimeDisplayService.getTravelDisplayInfo(
      segmentId,
      selectedMode,
      travelOptions
    );
  };

  // Get travel mode options for UI
  const getTravelModeOptions = (segmentId: string, selectedMode: 'driving' | 'walking') => {
    return TravelTimeDisplayService.getTravelModeOptions(
      segmentId,
      selectedMode,
      travelOptions
    );
  };

  // Format travel time for display
  const formatTravelTime = (duration: number) => {
    return TravelTimeDisplayService.formatTravelTime(duration);
  };

  // Clean schedule recalculation using the new service - memoized to prevent recreation
  const recalculateEntireSchedule = React.useCallback(async () => {
    if (isRecalculating) {
      return;
    }
    
    console.log('üîÑ Starting schedule recalculation...', {
      availableTravelOptions: Object.keys(travelOptions).length,
      availableTravelModes: Object.keys(travelModes).length,
      currentTravelModes: travelModes
    });
    
    // Skip recalculation if no travel options are available yet (early call)
    if (Object.keys(travelOptions).length === 0 && currentItinerary.places?.length > 0) {
      console.log('‚è≠Ô∏è Skipping schedule recalculation - waiting for travel options to load');
      return;
    }
    
    setIsRecalculating(true);
    
    try {
      // Use the unified travel calculator for consistent calculations
      // Pass current travel options and modes to ensure real data is used
      const recalculatedItinerary = calculateUnifiedSchedule(
        itineraryState,
        isMultiDay(itineraryState) ? activeDay - 1 : undefined,
        travelOptions, // Pass current travel options
        travelModes    // Pass current travel modes
      );
      
      console.log('‚úÖ Schedule recalculation succeeded - updating itinerary state', {
        hasSchedule: !!(recalculatedItinerary.schedule || recalculatedItinerary.dailyItineraries?.[activeDay - 1]?.schedule),
        scheduleLength: recalculatedItinerary.schedule?.length || recalculatedItinerary.dailyItineraries?.[activeDay - 1]?.schedule?.length || 0,
        firstArrival: recalculatedItinerary.schedule?.[0]?.arrivalTime || recalculatedItinerary.dailyItineraries?.[activeDay - 1]?.schedule?.[0]?.arrivalTime,
        secondArrival: recalculatedItinerary.schedule?.[1]?.arrivalTime || recalculatedItinerary.dailyItineraries?.[activeDay - 1]?.schedule?.[1]?.arrivalTime,
        usedTravelModes: Object.keys(travelModes).length
      });
      setItineraryState(recalculatedItinerary);
      
      // Validate the result
      setTimeout(() => {
        validateSchedule(true);
      }, 100);
    } catch (error) {
      console.error('‚ùå Schedule recalculation error:', error);
    } finally {
      setIsRecalculating(false);
    }
  }, [itineraryState, travelOptions, travelModes, activeDay, isRecalculating, validateSchedule]);

  // Schedule validation with optional debugging - memoized
  const validateSchedule = React.useCallback((showDebug: boolean = false) => {
    // Use unified validation from UnifiedTravelCalculator
    const validation = UnifiedTravelCalculator.validateScheduleConsistency(
      currentItinerary.schedule || [],
      [] // We'll need to get travel segments from the itinerary
    );
    
    if (!validation.isValid && validation.errors.length > 0) {
      console.warn('‚ö†Ô∏è Schedule validation errors:', validation.errors);
      console.warn('üîß These errors indicate arrival time ‚â† previous departure + travel time');
    }
    
    return validation.isValid;
  }, [currentItinerary]);

  // Debug logging controls
  const startDebugLogging = React.useCallback(() => {
    DebugLogger.start();
    setIsDebugLogging(true);
    console.log('üîç Debug logging started');
  }, []);

  const stopDebugLogging = React.useCallback(() => {
    DebugLogger.stop();
    setIsDebugLogging(false);
    setDebugLogContent(DebugLogger.getLogsAsText());
    console.log('üîç Debug logging stopped');
  }, []);

  const clearDebugLogs = React.useCallback(() => {
    DebugLogger.clear();
    setDebugLogContent('');
    console.log('üóëÔ∏è Debug logs cleared');
  }, []);

  const exportDebugLogs = React.useCallback(() => {
    const logs = DebugLogger.getLogsAsText();
    // In a real app, you'd save this to a file or share it
    console.log('üìÑ Debug logs exported:', logs);
    Alert.alert(
      'Debug Logs',
      'Debug logs have been copied to console. Check the development console for the full log.',
      [{ text: 'OK' }]
    );
  }, []);

  // Debounced schedule validation when day changes
  React.useEffect(() => {
    const timer = setTimeout(() => {
      validateSchedule(true); // Show debug output
    }, 1000);
    
    return () => clearTimeout(timer);
  }, [activeDay]);

  // Calculate missing travel options with debouncing
  React.useEffect(() => {
    console.log('üîß Travel options useEffect triggered', {
      hasSchedule: !!currentItinerary.schedule,
      scheduleLength: currentItinerary.schedule?.length || 0,
      placesLength: currentItinerary.places?.length || 0,
      currentTravelOptionsCount: Object.keys(travelOptions).length
    });
    
    // Using memoized currentItinerary  
    if (!currentItinerary.places || currentItinerary.places.length === 0) {
      console.log('‚è≠Ô∏è Skipping travel options calculation - no places');
      return;
    }

    // Debounce to prevent excessive calculations
    const timer = setTimeout(() => {
      const missingOptions: string[] = [];
      
      console.log('üîç Checking for missing travel options...', {
        availableOptionKeys: Object.keys(travelOptions),
        availableModeKeys: Object.keys(travelModes)
      });
      
      // Check start-to-first-place
      if (currentItinerary.places.length > 0) {
        const firstPlace = currentItinerary.places[0];
        const startRideId = generateRideId('start', firstPlace.name, 0);
        
        console.log('üîç Checking start-to-first-place', {
          startRideId,
          hasOption: !!travelOptions[startRideId],
          firstPlaceName: firstPlace.name
        });
        
        if (!travelOptions[startRideId]) {
          missingOptions.push(startRideId);
          console.log('üìû Calling calculateTravelOptions for start-to-first', { startRideId });
          calculateTravelOptions(
            startRideId,
            startingLocation.address,
            firstPlace.address,
            startingLocation.coordinates,
            firstPlace.coordinates
          );
        }
      }

      // Check place-to-place
      for (let i = 1; i < currentItinerary.places.length; i++) {
        const prevPlace = currentItinerary.places[i - 1];
        const currentPlace = currentItinerary.places[i];
        const rideId = generateRideId(prevPlace.name, currentPlace.name, i);
        
        console.log(`üîç Checking place ${i}`, {
          rideId,
          hasOption: !!travelOptions[rideId],
          from: prevPlace.name,
          to: currentPlace.name
        });
        
        if (!travelOptions[rideId]) {
          missingOptions.push(rideId);
          console.log(`üìû Calling calculateTravelOptions for place ${i}`, { rideId });
          calculateTravelOptions(
            rideId,
            prevPlace.address,
            currentPlace.address,
            prevPlace.coordinates,
            currentPlace.coordinates
          );
        }
      }
      
      console.log('üìä Travel options check complete', {
        missingOptionsCount: missingOptions.length,
        missingOptions: missingOptions.slice(0, 3) // Show first 3
      });

      // Check return travel
      if (currentItinerary.places.length > 0) {
        const lastPlace = currentItinerary.places[currentItinerary.places.length - 1];
        const returnRideId = generateRideId(lastPlace.name, 'return', 999);
        
        if (!travelOptions[returnRideId]) {
          missingOptions.push(returnRideId);
          calculateTravelOptions(
            returnRideId,
            lastPlace.address,
            returnLocation?.address || startingLocation.address,
            lastPlace.coordinates,
            returnLocation?.coordinates || startingLocation.coordinates
          );
        }
      }

      // Trigger recalculation if all options are available
      console.log('üéØ Travel options check - should trigger recalculation?', {
        missingOptionsCount: missingOptions.length,
        isRecalculating,
        shouldTrigger: missingOptions.length === 0 && !isRecalculating
      });
      
      if (missingOptions.length === 0 && !isRecalculating) {
        console.log('üöÄ All travel options loaded - triggering full recalculation');
        recalculateEntireSchedule();
      }
    }, 500);

    return () => clearTimeout(timer);
  }, [activeDay, currentItinerary, travelOptions]);


  const handleCheckout = () => {
    setShowCheckout(true);
  };

  const handleConfirmBooking = () => {
    setShowCheckout(false);
    setShowConfirmation(true);
  };

  const handleBackToHome = () => {
    setShowConfirmation(false);
    setTicketBookings([]);
    setRideBookings([]);
    onBackToForm();
  };

  const handleViewItinerary = () => {
    setShowConfirmation(false);
    // Keep the current state for viewing itinerary
  };

  const handleDiningReservation = (diningStop: DiningStop) => {
    console.log('üîî Reserve button pressed for:', diningStop.name);
    setSelectedDiningStop(diningStop);
    setShowReservationModal(true);
    console.log('üîî Modal state set to true');
  };

  const handlePrintItinerary = () => {
    setShowPrintItinerary(true);
  };

  const generateRideId = (from: string, to: string, index: number) => {
    return `${from.replace(/\s/g, '')}_${to.replace(/\s/g, '')}_${index}`;
  };

  const handleTravelSegmentPress = (
    fromLocation: string,
    toLocation: string,
    fromCoordinates: { latitude: number; longitude: number },
    toCoordinates: { latitude: number; longitude: number },
    distance: number,
    estimatedDuration: number,
    rideId: string,
    scheduledTime?: string
  ) => {
    setSelectedRideSegment({
      fromLocation,
      toLocation,
      fromCoordinates,
      toCoordinates,
      distance,
      estimatedDuration,
      rideId,
      scheduledTime,
    });
    setShowRideModal(true);
  };

  const renderReturnTravelBlock = () => {
    if (currentItinerary.places.length === 0) {
      return null;
    }

    // Get return travel information using unified display service
    const lastPlace = currentItinerary.places[currentItinerary.places.length - 1];
    const returnRideId = generateRideId(lastPlace.name, 'return', 999);
    const selectedReturnMode = travelModes[returnRideId] || 'driving';
    const returnDisplayInfo = getTravelDisplayInfo(returnRideId, selectedReturnMode);
    
    // Use unified display service values with fallbacks
    const returnTravelTime = returnDisplayInfo.duration || lastPlace?.returnTravelTime || 15;
    const returnTravelMode = returnDisplayInfo.mode;
    const returnTravelIcon = returnDisplayInfo.icon;

    const destinationText = returnLocation ? 'return point' : 'starting point';

    // Check if there's already a return dining stop (extra schedule item)
    const hasReturnDiningStop = currentItinerary.schedule.length > currentItinerary.places.length;

    // If there's a return dining stop, don't show anything
    // The travel and dining stop will be shown by the dining stop's own rendering
    if (hasReturnDiningStop) {
      return null;
    }
    const isReturnRideBooked = rideBookings.some(ride => ride.id === returnRideId);
    const canBookReturnRide = true; // Always allow ride booking for driving mode

    const handleReturnTravelIndicatorPress = () => {
      if (!canBookReturnRide) return;
      
      setSelectedRideSegment({
        fromLocation: lastPlace.address,
        toLocation: returnLocation?.address || startingLocation.address,
        fromCoordinates: lastPlace.coordinates,
        toCoordinates: returnLocation?.coordinates || startingLocation.coordinates,
        distance: lastPlace.distanceFromStart || 1000,
        estimatedDuration: returnTravelTime,
        rideId: returnRideId,
        scheduledTime: currentItinerary.schedule[currentItinerary.schedule.length - 1]?.departureTime,
      });
      setShowRideModal(true);
    };

    // Calculate travel options for return travel if not already calculated (moved to component level)
    // This will be handled by the main travel options calculation useEffect

    // Check if we have travel options calculated for return travel
    const returnTravelOptions = travelOptions[returnRideId];
    const selectedReturnTravelMode = travelModes[returnRideId] || 'driving'; // Will be set by calculateTravelOptions with smart default
    
    // Show DualTravelIndicator if walking time is reasonable (‚â§ 25 minutes)
    // Always show for choice, regardless of driving time
    const shouldShowReturnDualIndicator = returnTravelOptions && 
      returnTravelOptions.walking.duration <= 25;

    return (
      <View>
        <View style={styles.compactTravelRow}>
          {shouldShowReturnDualIndicator ? (
            <DualTravelIndicator
              travelOptions={returnTravelOptions}
              selectedMode={selectedReturnTravelMode}
              onModeChange={(mode) => handleTravelModeChange(returnRideId, mode)}
              onRideBookPress={handleReturnTravelIndicatorPress}
              isRideBooked={isReturnRideBooked}
              canBookRide={selectedReturnTravelMode === 'driving'}
              scheduledTime={currentItinerary.schedule[currentItinerary.schedule.length - 1]?.departureTime}
              day={isMultiDay ? activeDay : undefined}
            />
          ) : (
            <TravelIndicator
              travelTime={returnTravelTime}
              travelIcon={returnTravelIcon}
              fromLocation={lastPlace.address}
              toLocation={returnLocation?.address || startingLocation.address}
              fromCoordinates={lastPlace.coordinates}
              toCoordinates={returnLocation?.coordinates || startingLocation.coordinates}
              distance={lastPlace.distanceFromStart || 1000}
              rideId={returnRideId}
              onPress={handleReturnTravelIndicatorPress}
              isRideBooked={isReturnRideBooked}
              canBookRide={canBookReturnRide}
              scheduledTime={currentItinerary.schedule[currentItinerary.schedule.length - 1]?.departureTime}
              day={isMultiDay ? activeDay : undefined}
            />
          )}
          
          {/* Return Dining Stop Button */}
          <TouchableOpacity 
            style={styles.circularAddFoodButton}
            onPress={() => handleReturnDiningStopPress()}
            activeOpacity={0.7}
          >
            <Text style={styles.circularAddFoodIcon}>+</Text>
          </TouchableOpacity>
        </View>
      </View>
    );
  };


  const renderPlaceCard = (place: PlaceRecommendation, index: number) => {
    const scheduleItem = currentItinerary.schedule.find(s => s.place.place_id === place.place_id);
    const scheduleIndex = currentItinerary.schedule.findIndex(s => s.place.place_id === place.place_id);
    const workingHours = formatWorkingHours(place);
    
    return (
      <View key={place.place_id} style={[styles.placeCard, { borderColor: '#4ECDC4', borderWidth: 2 }]}>
        {/* Change Place Button - Top Right */}
        <TouchableOpacity 
          style={styles.changePlaceButton}
          onPress={() => handleChangePlacePress(place, index)}
          activeOpacity={0.7}
        >
          <Text style={styles.changePlaceIcon}>‚áÑ</Text>
        </TouchableOpacity>

        <View style={styles.placeHeader}>
          <View style={styles.placeNumber}>
            <Text style={styles.placeNumberText}>{index + 1}</Text>
          </View>
          <View style={styles.placeInfo}>
            <Text style={styles.placeName}>{place.name}</Text>
            <Text style={styles.placeAddress}>{place.address}</Text>
            <View style={styles.placeDetails}>
              <Text style={styles.rating}>‚≠ê {place.rating?.toString() || '0'}</Text>
              {place.price_level !== undefined && (
                <Text style={styles.price}>
                  üí∞ {'$'.repeat(Math.max(1, place.price_level || 1))}
                </Text>
              )}
            </View>
          </View>
          <PlaceImage 
            place={place} 
            width={80} 
            height={80} 
            borderRadius={12}
          />
        </View>
        
        {scheduleItem && (
          <View style={styles.scheduleInfo}>
            <View style={styles.scheduleRow}>
              <View style={styles.scheduleLeft}>
                <Text style={styles.scheduleText}>
                  üìÖ {scheduleItem.arrivalTime} - {scheduleItem.departureTime}
                </Text>
                <View style={styles.visitInfoRow}>
                  <TouchableOpacity 
                    style={styles.visitDurationButton}
                    onPress={() => {
                      if (scheduleItem && scheduleIndex >= 0) {
                        handleVisitDurationPress(
                          scheduleIndex, 
                          scheduleItem.visitDuration, 
                          place.name
                        );
                      }
                    }}
                    activeOpacity={0.7}
                  >
                    <Text style={styles.visitDurationText}>
                      üïí {scheduleItem?.visitDuration || 60} min visit
                    </Text>
                    <Text style={styles.editIcon}>‚úèÔ∏è</Text>
                  </TouchableOpacity>
                  {place.ticket_info && place.ticket_info.length > 0 && (
                    <Text style={styles.ticketFeeText}>
                      üé´ {place.ticket_info[0].price}
                    </Text>
                  )}
                </View>
                {scheduleItem.warning && (
                  <View style={styles.warningContainer}>
                    <Text style={styles.warningText}>
                      {scheduleItem.warning}
                    </Text>
                  </View>
                )}
              </View>
              {workingHours && (
                <View style={styles.workingHoursCompact}>
                  <Text style={styles.workingHoursCompactLabel}>Today</Text>
                  <Text style={[
                    styles.workingHoursCompactTime,
                    { color: workingHours.isOpen ? '#27ae60' : '#e74c3c' }
                  ]}>
                    {workingHours.todayHours}
                  </Text>
                </View>
              )}
            </View>
          </View>
        )}

        {/* Extended Working Hours Section - Show only if we have space and weekly hours available */}
        {workingHours && workingHours.weeklyHours && (
          <View style={styles.extendedHoursContainer}>
            <TouchableOpacity 
              style={styles.extendedHoursHeader}
              onPress={() => toggleHoursExpansion(place.place_id)}
              activeOpacity={0.7}
            >
              <Text style={styles.extendedHoursTitle}>
                üìÖ Full Week Schedule
              </Text>
              <Text style={styles.expandHoursText}>
                {expandedHours.has(place.place_id) ? 'üîº' : 'üîΩ'}
              </Text>
            </TouchableOpacity>
            
            {expandedHours.has(place.place_id) && (
              <View style={styles.allHoursContainer}>
                {workingHours.weeklyHours.map((dayInfo, idx) => (
                  <Text 
                    key={idx} 
                    style={[
                      styles.dayHoursText,
                      dayInfo.isToday && styles.dayHoursTodayText,
                      dayInfo.isClosed && styles.dayHoursClosedText
                    ]}
                  >
                    {dayInfo.isToday ? '‚Üí ' : '  '}{dayInfo.day}: {dayInfo.hours}
                    {dayInfo.isToday ? ' (Today)' : ''}
                  </Text>
                ))}
              </View>
            )}
          </View>
        )}
        
        {place.description && (
          <Text style={styles.placeDescription} numberOfLines={3}>
            {place.description}
          </Text>
        )}
        
        {/* Ticket Booking Card */}
        <TicketBookingCard
          place={place}
          onTicketSelect={handleTicketSelect}
          selectedTickets={ticketBookings}
          day={isMultiDay ? activeDay : undefined}
          arrivalTime={currentItinerary.schedule[index]?.arrivalTime}
        />
        
        
        {place.busynessLevel !== undefined && (
          <View style={styles.busynessContainer}>
            <Text style={styles.busynessLabel}>Crowd Level: </Text>
            <View style={styles.busynessBar}>
              <View 
                style={[
                  styles.busynessFill, 
                  { 
                    width: `${place.busynessLevel || 0}%`,
                    backgroundColor: (place.busynessLevel || 0) > 70 ? '#e74c3c' : 
                                   (place.busynessLevel || 0) > 40 ? '#f39c12' : '#27ae60'
                  }
                ]} 
              />
            </View>
            <Text style={styles.busynessText}>{place.busynessLevel?.toString() || '0'}%</Text>
          </View>
        )}
      </View>
    );
  };

  const renderSummaryCard = () => {
    const diningStats = getDiningStopStats();
    
    
    return (
      <View style={styles.summaryCard}>
        <Text style={styles.summaryTitle}>üìä Itinerary Summary</Text>
        
        {/* Basic Info */}
        <View style={styles.summaryRow}>
          <Text style={styles.summaryLabel}>Total Places:</Text>
          <Text style={styles.summaryValue}>{currentItinerary.places.length.toString()}</Text>
        </View>
        
        {/* NEW: Food Stops */}
        <View style={styles.summaryRow}>
          <Text style={styles.summaryLabel}>üçΩÔ∏è Food Stops:</Text>
          <Text style={styles.summaryValue}>{diningStats.totalStops.toString()}</Text>
        </View>
        
        {/* NEW: Food Time */}
        {diningStats.totalStops > 0 && (
          <View style={styles.summaryRow}>
            <Text style={styles.summaryLabel}>üïê Food Time:</Text>
            <Text style={styles.summaryValue}>{diningStats.formattedTime}</Text>
          </View>
        )}
        
        {/* NEW: Visiting Time */}
        <View style={styles.summaryRow}>
          <Text style={styles.summaryLabel}>üéØ Visiting Time:</Text>
          <Text style={styles.summaryValue}>
            {(() => {
              // Calculate visiting time from current schedule (includes place replacements)
              let visitingTimeMinutes = 0;
              currentItinerary.schedule.forEach(item => {
                visitingTimeMinutes += item.visitDuration || 0;
              });
              return `${Math.floor(visitingTimeMinutes / 60)}h ${Math.round(visitingTimeMinutes % 60)}m`;
            })()}
          </Text>
        </View>
        
        {/* NEW: Travel Time */}
        <View style={styles.summaryRow}>
          <Text style={styles.summaryLabel}>üöó Travel Time:</Text>
          <Text style={styles.summaryValue}>
            {formatSafeDuration(calculateActualTravelTime())}
          </Text>
        </View>
        
        {/* NEW: Total Duration */}
        <View style={styles.summaryRow}>
          <Text style={styles.summaryLabel}>‚è±Ô∏è Total Duration:</Text>
          <Text style={[styles.summaryValue, styles.totalDurationHighlight]}>
            {formatSafeDuration(calculateActualTotalDuration())}
          </Text>
        </View>
      </View>
    );
  };

  return (
    <View style={styles.container}>
      {/* Sticky Header */}
      <View style={styles.stickyHeader}>
        <TouchableOpacity style={styles.backButton} onPress={onBackToForm}>
          <Text style={styles.backButtonText}>‚Üê Back</Text>
        </TouchableOpacity>
        <Text style={styles.headerTitle}>Your Itinerary</Text>
        <View style={styles.headerSpacer} />
      </View>
      
      {/* Fixed Multi-Day Navigation */}
      {isMultiDay(itinerary) && (
        <View style={styles.fixedDayNavigation}>
          <View style={styles.dayNavigationHeader}>
            <View style={styles.dayNavigationStats}>
              <Text style={styles.dayNavigationSubtitle}>
                {itinerary.totalDays} day{itinerary.totalDays > 1 ? 's' : ''} ‚Ä¢ {itinerary.totalPlaces} places
              </Text>
              <Text style={styles.dayNavigationTimes}>
                {Math.round((itinerary.totalVisitingTime || 0) / 60)}h visiting ‚Ä¢ {Math.round((itinerary.totalTravelTime || 0) / 60)}h travel
              </Text>
            </View>
          </View>
          <ScrollView 
            horizontal 
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={styles.dayTabsContent}
            bounces={false}
          >
            {itinerary.dailyItineraries.map((dailyItinerary) => (
              <TouchableOpacity
                key={dailyItinerary.day}
                style={[
                  styles.dayTab,
                  activeDay === dailyItinerary.day && styles.dayTabActive
                ]}
                onPress={() => {
                  // FIXED: Only preserve existing bookings when switching days - don't auto-add new ones
                  const newActiveDay = dailyItinerary.day;
                  console.log(`üîÑ Switching to day ${newActiveDay} - preserving existing bookings only`);
                  
                  // Simply switch to the new day without adding new bookings
                  setActiveDay(newActiveDay);
                }}
                activeOpacity={0.7}
              >
                <View style={styles.dayTabContent}>
                  <View style={styles.dayTabHeader}>
                    <Text style={[
                      styles.dayTabText,
                      activeDay === dailyItinerary.day && styles.dayTabTextActive
                    ]}>
                      Day {dailyItinerary.day}
                    </Text>
                    {activeDay === dailyItinerary.day && (
                      <View style={styles.activeIndicator} />
                    )}
                  </View>
                  <Text style={[
                    styles.dayTabDate,
                    activeDay === dailyItinerary.day && styles.dayTabDateActive
                  ]}>
                    {(() => {
                      const [year, month, day] = dailyItinerary.date.split('-').map(Number);
                      return new Date(year, month - 1, day).toLocaleDateString('en-US', { 
                        month: 'short', 
                        day: 'numeric' 
                      });
                    })()}
                  </Text>
                  <View style={styles.dayTabStats}>
                    <Text style={[
                      styles.dayTabInfo,
                      activeDay === dailyItinerary.day && styles.dayTabInfoActive
                    ]}>
                      {dailyItinerary.places.length} places
                    </Text>
                  </View>
                </View>
              </TouchableOpacity>
            ))}
          </ScrollView>
        </View>
      )}
      
      {/* Scrollable Content */}
      <ScrollView style={styles.scrollableContent} showsVerticalScrollIndicator={false}>

      {/* Collapsible Current Day Summary */}
      <View style={styles.summaryContainer}>
        <TouchableOpacity 
          style={styles.summaryHeader}
          onPress={() => {
            const newExpanded = !summaryExpanded;
            setSummaryExpanded(newExpanded);
            
            Animated.parallel([
              Animated.timing(summaryHeight, {
                toValue: newExpanded ? 1 : 0,
                duration: 300,
                useNativeDriver: false,
              }),
              Animated.timing(summaryRotation, {
                toValue: newExpanded ? 1 : 0,
                duration: 300,
                useNativeDriver: false,
              }),
            ]).start();
          }}
          activeOpacity={0.7}
        >
          <View style={styles.summaryHeaderContent}>
            <Text style={styles.summaryTitle}>üìÖ Day {isMultiDay(itinerary) ? activeDay : 1} Summary</Text>
            <View style={styles.summaryQuickStats}>
              <Text style={styles.summaryQuickText}>
                {currentItinerary.places.length}p ‚Ä¢ {(() => {
                  const totalDiningStops = currentItinerary.schedule.reduce((total, item) => 
                    total + (item.diningStops?.length || 0), 0
                  );
                  return totalDiningStops > 0 ? `${totalDiningStops}f` : '';
                })()}
              </Text>
            </View>
          </View>
          <Animated.View style={[styles.summaryChevron, { 
            transform: [{ 
              rotate: summaryRotation.interpolate({
                inputRange: [0, 1],
                outputRange: ['0deg', '180deg'],
              })
            }] 
          }]}>
            <Text style={styles.summaryChevronText}>‚ñº</Text>
          </Animated.View>
        </TouchableOpacity>
        
        <Animated.View style={[styles.summaryContent, { 
          maxHeight: summaryHeight.interpolate({
            inputRange: [0, 1],
            outputRange: [0, 350],
          }),
          opacity: summaryHeight,
        }]}>
          <View style={styles.summaryGrid}>
            <View style={styles.summaryStat}>
              <Text style={styles.summaryStatIcon}>üéØ</Text>
              <Text style={styles.summaryStatValue}>
                {currentItinerary.places.length}
              </Text>
              <Text style={styles.summaryStatLabel}>Places</Text>
            </View>
            <View style={styles.summaryStat}>
              <Text style={styles.summaryStatIcon}>üçΩÔ∏è</Text>
              <Text style={styles.summaryStatValue}>
                {(() => {
                  const totalDiningStops = currentItinerary.schedule.reduce((total, item) => 
                    total + (item.diningStops?.length || 0), 0
                  );
                  return totalDiningStops;
                })()}
              </Text>
              <Text style={styles.summaryStatLabel}>Food Stops</Text>
            </View>
            <View style={styles.summaryStat}>
              <Text style={styles.summaryStatIcon}>‚è±Ô∏è</Text>
              <Text style={styles.summaryStatValue}>
                {(() => {
                  // Calculate visit time from actual schedule (excluding food places)
                  let visitTimeMinutes = 0;
                  currentItinerary.schedule.forEach(item => {
                    visitTimeMinutes += item.visitDuration || 0;
                  });
                  return `${Math.floor(visitTimeMinutes / 60)}h ${visitTimeMinutes % 60}m`;
                })()}
              </Text>
              <Text style={styles.summaryStatLabel}>Visit Time</Text>
            </View>
            <View style={styles.summaryStat}>
              <Text style={styles.summaryStatIcon}>üöó</Text>
              <Text style={styles.summaryStatValue}>
                {formatSafeDuration(calculateCombinedTravelTime())}
              </Text>
              <Text style={styles.summaryStatLabel}>Travel Time</Text>
            </View>
          </View>
          
          {/* Travel Time Breakdown */}
          <View style={styles.travelBreakdownContainer}>
            <Text style={styles.travelBreakdownTitle}>Travel Breakdown</Text>
            <View style={styles.travelBreakdownRow}>
              <View style={styles.travelModeItem}>
                <Text style={styles.travelModeIcon}>üö∂‚Äç‚ôÇÔ∏è</Text>
                <Text style={styles.travelModeLabel}>Walking</Text>
                <Text style={styles.travelModeTime}>
                  {(() => {
                    let walkingMinutes = 0;
                    currentItinerary.schedule.forEach((item, index) => {
                      const rideId = generateRideId(
                        index === 0 ? 'start' : currentItinerary.schedule[index - 1]?.place?.name || 'unknown',
                        item.place?.name || 'unknown',
                        index
                      );
                      const selectedMode = travelModes[rideId] || 'driving';
                      const segmentTravelOptions = travelOptions[rideId];
                      
                      if (segmentTravelOptions && segmentTravelOptions[selectedMode] && selectedMode === 'walking') {
                        walkingMinutes += segmentTravelOptions[selectedMode].duration;
                      }
                    });
                    
                    // Add dining stop walking time
                    currentItinerary.schedule.forEach(item => {
                      if (item.diningStops && Array.isArray(item.diningStops)) {
                        item.diningStops.forEach(stop => {
                          if (stop.travel_breakdown) {
                            if (stop.travel_breakdown.travel_to_mode === 'walking') {
                              walkingMinutes += stop.travel_breakdown.travel_to_restaurant || 0;
                            }
                            if (stop.travel_breakdown.travel_from_mode === 'walking') {
                              walkingMinutes += stop.travel_breakdown.travel_from_restaurant || 0;
                            }
                          }
                        });
                      }
                    });
                    
                    // Add return travel walking time
                    const lastPlace = currentItinerary.places[currentItinerary.places.length - 1];
                    if (lastPlace) {
                      const returnRideId = generateRideId(lastPlace.name, 'return', 999);
                      const selectedReturnMode = travelModes[returnRideId] || 'driving';
                      const returnTravelOptions = travelOptions[returnRideId];
                      
                      if (returnTravelOptions && returnTravelOptions[selectedReturnMode] && selectedReturnMode === 'walking') {
                        walkingMinutes += returnTravelOptions[selectedReturnMode].duration;
                      } else if (lastPlace?.returnTravelTime && selectedReturnMode === 'walking') {
                        // Fallback to place data
                        walkingMinutes += lastPlace.returnTravelTime;
                      }
                    }
                    
                    return `${Math.floor(walkingMinutes / 60)}h ${walkingMinutes % 60}m`;
                  })()}
                </Text>
              </View>
              <View style={styles.travelModeItem}>
                <Text style={styles.travelModeIcon}>üöó</Text>
                <Text style={styles.travelModeLabel}>Driving</Text>
                <Text style={styles.travelModeTime}>
                  {(() => {
                    let drivingMinutes = 0;
                    currentItinerary.schedule.forEach((item, index) => {
                      const rideId = generateRideId(
                        index === 0 ? 'start' : currentItinerary.schedule[index - 1]?.place?.name || 'unknown',
                        item.place?.name || 'unknown',
                        index
                      );
                      const selectedMode = travelModes[rideId] || 'driving';
                      const segmentTravelOptions = travelOptions[rideId];
                      
                      if (segmentTravelOptions && segmentTravelOptions[selectedMode] && selectedMode === 'driving') {
                        drivingMinutes += segmentTravelOptions[selectedMode].duration;
                      } else if (!segmentTravelOptions) {
                        // Fallback: use travelTimeFromPrevious and assume driving
                        drivingMinutes += item.travelTimeFromPrevious || 0;
                      }
                    });
                    
                    // Add dining stop driving time
                    currentItinerary.schedule.forEach(item => {
                      if (item.diningStops && Array.isArray(item.diningStops)) {
                        item.diningStops.forEach(stop => {
                          if (stop.travel_breakdown) {
                            if (stop.travel_breakdown.travel_to_mode === 'driving') {
                              drivingMinutes += stop.travel_breakdown.travel_to_restaurant || 0;
                            }
                            if (stop.travel_breakdown.travel_from_mode === 'driving') {
                              drivingMinutes += stop.travel_breakdown.travel_from_restaurant || 0;
                            }
                          }
                        });
                      }
                    });
                    
                    // Add return travel driving time
                    const lastPlace = currentItinerary.places[currentItinerary.places.length - 1];
                    if (lastPlace) {
                      const returnRideId = generateRideId(lastPlace.name, 'return', 999);
                      const selectedReturnMode = travelModes[returnRideId] || 'driving';
                      const returnTravelOptions = travelOptions[returnRideId];
                      
                      if (returnTravelOptions && returnTravelOptions[selectedReturnMode] && selectedReturnMode === 'driving') {
                        drivingMinutes += returnTravelOptions[selectedReturnMode].duration;
                      } else if (lastPlace?.returnTravelTime && selectedReturnMode === 'driving') {
                        // Fallback to place data
                        drivingMinutes += lastPlace.returnTravelTime;
                      } else if (lastPlace?.returnTravelTime) {
                        // If return travel time exists but mode is not specified, assume driving
                        drivingMinutes += lastPlace.returnTravelTime;
                      }
                    }
                    
                    return `${Math.floor(drivingMinutes / 60)}h ${drivingMinutes % 60}m`;
                  })()}
                </Text>
              </View>
            </View>
          </View>
          
          <View style={styles.totalDurationRow}>
            <Text style={styles.totalDurationLabel}>‚è∞ Total Duration</Text>
            <Text style={styles.totalDurationValue}>
              {calculateActualTotalDuration()}
            </Text>
          </View>
          
          {/* Move Optimization and Missed boxes into the summary using an IIFE for proper scoping */}
          {(() => {
            const hasOptimization = currentItinerary.optimizationNotes && currentItinerary.optimizationNotes.length > 0;
            const hasMissed = currentItinerary.uncoveredInterests && currentItinerary.uncoveredInterests.length > 0;
            return (
              <View style={styles.summaryInfoRow}>
                {hasOptimization && (
                  <TouchableOpacity 
                    style={[styles.squareCard, styles.squareCardInSummary]} 
                    activeOpacity={0.8}
                    onPress={() => setActiveModal('optimization')}
                  >
                    <Text style={styles.squareCardIcon}>üí°</Text>
                    <Text style={styles.squareCardTitle}>Optimization</Text>
                    <Text style={styles.squareCardBadge}>{currentItinerary.optimizationNotes.length}</Text>
                    <Text style={styles.squareCardSubtitle}>Notes</Text>
                  </TouchableOpacity>
                )}
                {hasMissed && (
                  <TouchableOpacity 
                    style={[styles.squareCard, styles.squareCardInSummary]} 
                    activeOpacity={0.8}
                    onPress={() => setActiveModal('missed')}
                  >
                    <Text style={styles.squareCardIcon}>‚ö†Ô∏è</Text>
                    <Text style={styles.squareCardTitle}>Missed</Text>
                    <Text style={styles.squareCardBadge}>{currentItinerary.uncoveredInterests.length}</Text>
                    <Text style={styles.squareCardSubtitle}>Interests</Text>
                  </TouchableOpacity>
                )}
              </View>
            );
          })()}
        </Animated.View>
      </View>

      {/* Map */}
      <View style={styles.mapContainer}>
        {Platform.OS === 'ios' || Platform.OS === 'android' ? (
          <>
          <MapView
            ref={mapRef}
            style={styles.map}
            region={mapRegion}
            showsUserLocation={true}
            showsMyLocationButton={true}
          >
            {/* Starting Point Marker */}
            <Marker
              coordinate={{
                latitude: startingLocation.coordinates.latitude,
                longitude: startingLocation.coordinates.longitude,
              }}
              title="Starting Point"
              description={startingLocation.address}
            >
              <View style={styles.startMarkerContainer}>
                <Text style={styles.startMarkerText}>üèÅ</Text>
              </View>
            </Marker>

            {/* Return Point Marker */}
            {returnLocation && (
              <Marker
                coordinate={{
                  latitude: returnLocation.coordinates.latitude,
                  longitude: returnLocation.coordinates.longitude,
                }}
                title="Return Point"
                description={returnLocation.address}
              >
                <View style={styles.returnMarkerContainer}>
                  <Text style={styles.returnMarkerText}>üè†</Text>
                </View>
              </Marker>
            )}

            {currentItinerary.places.map((place, index) => {
              // Debug logging for map marker coordinates
              console.log(`üó∫Ô∏è Map marker ${index + 1} for ${place.name}:`, {
                coordinates: place.coordinates,
                latitude: place.coordinates?.latitude,
                longitude: place.coordinates?.longitude,
                address: place.address,
                fullPlace: place
              });
              
              // Ensure we have valid coordinates before rendering marker
              if (!place.coordinates || !place.coordinates.latitude || !place.coordinates.longitude) {
                console.warn(`‚ö†Ô∏è Skipping map marker for ${place.name} - missing coordinates`);
                return null;
              }
              
              // Validate coordinates are numeric and within reasonable bounds
              const lat = parseFloat(place.coordinates.latitude);
              const lng = parseFloat(place.coordinates.longitude);
              
              if (isNaN(lat) || isNaN(lng) || lat < 39 || lat > 41 || lng > -74 || lng < -76) {
                console.warn(`‚ö†Ô∏è Skipping map marker for ${place.name} - invalid coordinates: ${lat}, ${lng}`);
                return null;
              }
              
              return (
                <Marker
                  key={place.place_id}
                  coordinate={{
                    latitude: lat,
                    longitude: lng,
                  }}
                  title={`${index + 1}. ${place.name}`}
                  description={place.address}
                >
                  <View style={styles.markerContainer}>
                    <Text style={styles.markerText}>{index + 1}</Text>
                  </View>
                </Marker>
              );
            })}

            {/* Dining Stop Markers */}
            {currentItinerary.schedule.map((scheduleItem, scheduleIndex) => 
              scheduleItem.diningStops?.map((diningStop, diningIndex) => (
                <Marker
                  key={`dining-${diningStop.place_id}-${scheduleIndex}-${diningIndex}`}
                  coordinate={{
                    latitude: diningStop.coordinates.latitude,
                    longitude: diningStop.coordinates.longitude,
                  }}
                  title={diningStop.name}
                  description={`${diningStop.meal_type.charAt(0).toUpperCase() + diningStop.meal_type.slice(1)} ‚Ä¢ ${diningStop.address}`}
                >
                  <View style={styles.diningMarkerContainer}>
                    <Text style={styles.diningMarkerText}>
                      {diningStop.meal_type === 'breakfast' && 'ü•ê'}
                      {diningStop.meal_type === 'brunch' && 'ü•û'}
                      {diningStop.meal_type === 'coffee' && '‚òï'}
                      {diningStop.meal_type === 'lunch' && 'üçΩÔ∏è'}
                      {diningStop.meal_type === 'dinner' && 'üç∑'}
                      {diningStop.meal_type === 'drinks' && 'üç∏'}
                      {!['breakfast', 'brunch', 'coffee', 'lunch', 'dinner', 'drinks'].includes(diningStop.meal_type) && 'üç¥'}
                    </Text>
                  </View>
                </Marker>
              )) || []
            )}


            {(() => {
              const routeCoordinates = generateCompleteRouteCoordinates();
              return routeCoordinates.length > 1 && (
                <Polyline
                  coordinates={routeCoordinates}
                  strokeColor="#3498db"
                  strokeWidth={3}
                />
              );
            })()}
          </MapView>
          
          {/* Zoom Controls */}
          <View style={styles.zoomControls}>
            <TouchableOpacity style={styles.zoomButton} onPress={zoomIn}>
              <Text style={styles.zoomButtonText}>+</Text>
            </TouchableOpacity>
            <TouchableOpacity style={styles.zoomButton} onPress={zoomOut}>
              <Text style={styles.zoomButtonText}>‚àí</Text>
            </TouchableOpacity>
          </View>
          </>
        ) : (
          <View style={styles.mapUnavailable}>
            <Text style={styles.mapUnavailableText}>Map view not supported on this platform.</Text>
          </View>
        )}
      </View>

      {/* Square Info Cards Grid */}
      {(() => {
        const diningStats = getDiningStopStats();
        const hasOptimization = currentItinerary.optimizationNotes && currentItinerary.optimizationNotes.length > 0;
        const hasMissed = currentItinerary.uncoveredInterests && currentItinerary.uncoveredInterests.length > 0;
        const hasPopular = currentItinerary.missedPopularPlaces && currentItinerary.missedPopularPlaces.length > 0;
        const hasDining = diningStats.totalStops > 0;

        const totalSquares = [hasOptimization, hasMissed, hasPopular, hasDining].filter(Boolean).length;

        return (
          <View style={[
            styles.infoCardsGrid,
            totalSquares === 2 ? styles.infoCardsGridTwoItems : {},
            totalSquares === 1 ? styles.infoCardsGridOneItem : {}
          ]}>
            {/* Optimization Notes - Square Card */}
            {hasPopular && (
              <TouchableOpacity 
                style={[
                  styles.squareCard,
                  totalSquares === 3 ? styles.squareCardThreePerRow : {},
                  totalSquares === 2 ? styles.squareCardTwoPerRow : {},
                  totalSquares === 1 ? styles.squareCardOnePerRow : {}
                ]} 
                activeOpacity={0.8}
                onPress={() => setActiveModal('popular')}
              >
                <Text style={styles.squareCardIcon}>üåü</Text>
                <Text style={styles.squareCardTitle}>Popular</Text>
                <Text style={styles.squareCardBadge}>{currentItinerary.missedPopularPlaces.length}</Text>
                <Text style={styles.squareCardSubtitle}>Places</Text>
              </TouchableOpacity>
            )}

            {/* Meal Breakdown - Square Card */}
            {hasDining && (
              <TouchableOpacity 
                style={[
                  styles.squareCard,
                  totalSquares === 3 ? styles.squareCardThreePerRow : {},
                  totalSquares === 2 ? styles.squareCardTwoPerRow : {},
                  totalSquares === 1 ? styles.squareCardOnePerRow : {}
                ]} 
                activeOpacity={0.8}
                onPress={() => setActiveModal('dining')}
              >
                <Text style={styles.squareCardIcon}>üçΩÔ∏è</Text>
                <Text style={styles.squareCardTitle}>Dining</Text>
                <Text style={styles.squareCardBadge}>{diningStats.totalStops}</Text>
                <Text style={styles.squareCardSubtitle}>Stops</Text>
              </TouchableOpacity>
            )}
          </View>
        );
      })()}

      {/* Places List */}
      <View style={styles.placesContainer}>
        <Text style={styles.placesTitle}>üó∫Ô∏è Your Places</Text>
        
        {/* Starting Point */}
        <View style={styles.startingPointCard}>
          <View style={styles.startingPointHeader}>
            <View style={styles.startingPointIcon}>
              <Text style={styles.startingPointIconText}>üèÅ</Text>
            </View>
            <View style={styles.startingPointInfo}>
              <Text style={styles.startingPointTitle}>Starting Point</Text>
              <Text style={styles.startingPointAddress}>{startingLocation?.address}</Text>
            </View>
          </View>
        </View>

        {/* Compact Travel + Add Food Stop - Starting Point to First Place */}
        {currentItinerary?.places?.length > 0 && 
         (!currentItinerary?.schedule?.[0]?.diningStops || 
          currentItinerary?.schedule?.[0]?.diningStops?.length === 0) && (() => {
            const firstPlace = currentItinerary?.places?.[0];
            const startRideId = generateRideId('start', firstPlace?.name, 0);
            const selectedStartMode = travelModes[startRideId] || 'driving';
            const startDisplayInfo = getTravelDisplayInfo(startRideId, selectedStartMode);
            const startTravelTime = startDisplayInfo.duration || 15;
            const startTravelIcon = startDisplayInfo.icon;
            const isStartRideBooked = rideBookings.some(ride => ride.id === startRideId);
            const canBookStartRide = true; // Always allow ride booking for driving mode
            
            // Calculate travel options for start-to-first-place if not already calculated (moved to component level)
            // This will be handled by the main travel options calculation useEffect

            // Check if we have travel options calculated for start-to-first-place
            const startTravelOptions = travelOptions[startRideId];
            const selectedStartTravelMode = travelModes[startRideId] || 'driving'; // Will be set by calculateTravelOptions with smart default
            
            // Show DualTravelIndicator if walking time is reasonable (‚â§ 25 minutes)
            // Always show for choice, regardless of driving time
            const shouldShowStartDualIndicator = startTravelOptions && 
              startTravelOptions.walking.duration <= 25;

            return (
              <View style={styles.compactTravelRow}>
                {shouldShowStartDualIndicator ? (
                  <DualTravelIndicator
                    travelOptions={startTravelOptions}
                    selectedMode={selectedStartTravelMode}
                    onModeChange={(mode) => handleTravelModeChange(startRideId, mode)}
                    onRideBookPress={() => handleTravelSegmentPress(
                      startingLocation?.address,
                      firstPlace?.address,
                      startingLocation?.coordinates,
                      firstPlace?.coordinates,
                      firstPlace?.distanceFromPrevious ? firstPlace?.distanceFromPrevious * 1000 : 1000,
                      startTravelTime,
                      startRideId,
                      currentItinerary?.schedule?.[0]?.arrivalTime
                    )}
                    isRideBooked={isStartRideBooked}
                    canBookRide={selectedStartTravelMode === 'driving'}
                    scheduledTime={currentItinerary?.schedule?.[0]?.arrivalTime}
                    day={isMultiDay ? activeDay : undefined}
                  />
                ) : (
                  <TravelIndicator
                    travelTime={startTravelTime}
                    travelIcon={startTravelIcon}
                    fromLocation={startingLocation?.address}
                    toLocation={firstPlace?.address}
                    fromCoordinates={startingLocation?.coordinates}
                    toCoordinates={firstPlace?.coordinates}
                    distance={firstPlace?.distanceFromPrevious ? firstPlace?.distanceFromPrevious * 1000 : 1000}
                    rideId={startRideId}
                    onPress={() => handleTravelSegmentPress(
                      startingLocation?.address,
                      firstPlace?.address,
                      startingLocation?.coordinates,
                      firstPlace?.coordinates,
                      firstPlace?.distanceFromPrevious ? firstPlace?.distanceFromPrevious * 1000 : 1000,
                      startTravelTime,
                      startRideId,
                      currentItinerary?.schedule?.[0]?.arrivalTime
                    )}
                    isRideBooked={isStartRideBooked}
                    canBookRide={canBookStartRide}
                    scheduledTime={currentItinerary?.schedule?.[0]?.arrivalTime}
                    day={isMultiDay ? activeDay : undefined}
                  />
                )}
                <TouchableOpacity 
                  style={styles.circularAddFoodButton}
                  onPress={() => {
                    console.log('üçΩÔ∏è + Button pressed for dining before first place');
                    handleDiningStopPress(-1, 0);
                  }}
                  activeOpacity={0.7}
                >
                  <Text style={styles.circularAddFoodIcon}>+</Text>
                </TouchableOpacity>
              </View>
            );
          })()
        }


        {/* Render existing dining stops before first place */}
        {currentItinerary?.schedule?.[0]?.diningStops?.map((diningStop, diningIndex) => {
          // Dining debug pre-first
          return (
          <View key={`pre-first-${diningStop?.place_id}-${diningIndex}`}>
            {/* Compact Travel Indicators Row */}
            <View style={styles.compactTravelRow}>
              {(() => {
                const walkingTime = diningStop?.travel_breakdown?.travelToOptions?.walking?.duration || 999;
                const drivingTime = diningStop?.travel_breakdown?.travelToOptions?.driving?.duration || 0;
                const shouldShowDual = walkingTime <= 25 && drivingTime >= 1;
                const rideId = generateRideId('start', diningStop?.name, 'pre_first_dining_to');
                
                if (shouldShowDual && diningStop?.travel_breakdown?.travelToOptions) {
                  const travelOptions = {
                    walking: {
                      duration: walkingTime,
                      distance: Math.round((diningStop?.detour_distance || 1000) * 1.3),
                      icon: diningStop?.travel_breakdown?.travelToOptions?.walking?.icon,
                    },
                    driving: {
                      duration: drivingTime,
                      distance: diningStop?.detour_distance || 1000,
                      icon: diningStop?.travel_breakdown?.travelToOptions?.driving?.icon,
                    },
                    rideId,
                    fromLocation: startingLocation?.address,
                    toLocation: diningStop?.address,
                    fromCoordinates: startingLocation?.coordinates,
                    toCoordinates: diningStop?.coordinates,
                  };
                  
                  const selectedMode = travelModes[rideId] || (diningStop?.travel_breakdown?.travel_to_mode === 'walking' ? 'walking' : 'driving');
                  
                  return (
                    <DualTravelIndicator
                      travelOptions={travelOptions}
                      selectedMode={selectedMode}
                      onModeChange={(newMode) => {
                        console.log(`üö∂/üöó Dining stop travel mode changed to: ${newMode} for ${rideId}`);
                        handleDiningStopTravelModeChange(rideId, newMode, diningIndex, 0, 'to');
                      }}
                      isRideBooked={rideBookings.some(ride => ride.id === rideId)}
                      canBookRide={drivingTime >= 1}
                      scheduledTime={diningStop?.arrival_time}
                      day={isMultiDay ? activeDay : undefined}
                    />
                  );
                }
                
                return (
                  <TravelIndicator
                    travelTime={diningStop?.travel_breakdown?.travel_to_restaurant || 0}
                    travelIcon={diningStop?.travel_breakdown?.travel_to_icon || 'üöó'}
                    fromLocation={startingLocation?.address}
                    toLocation={diningStop?.address}
                    fromCoordinates={startingLocation?.coordinates}
                    toCoordinates={diningStop?.coordinates}
                    distance={diningStop?.detour_distance || 1000}
                    rideId={rideId}
                    onPress={() => handleTravelSegmentPress(
                      startingLocation?.address,
                      diningStop?.address,
                      startingLocation?.coordinates,
                      diningStop?.coordinates,
                      diningStop?.detour_distance || 1000,
                      diningStop?.travel_breakdown?.travel_to_restaurant || 0,
                      rideId,
                      diningStop?.arrival_time
                    )}
                    isRideBooked={rideBookings.some(ride => ride.id === rideId)}
                    canBookRide={(diningStop?.travel_breakdown?.travel_to_restaurant || 0) >= 1}
                    scheduledTime={diningStop?.arrival_time}
                    day={isMultiDay ? activeDay : undefined}
                  />
                );
              })()}
            </View>

            {/* Restaurant/Dining Stop */}
            <View style={styles.diningStopCard}>
              {/* Remove Button - Top Right */}
              <TouchableOpacity 
                style={styles.removeDiningButton}
                onPress={() => handleRemoveDiningStop(diningStop, 0, diningIndex)}
                activeOpacity={0.7}
              >
                <Text style={styles.removeDiningIcon}>√ó</Text>
              </TouchableOpacity>

              {/* Horizontal Layout - Text Left, Image Right */}
              <View style={styles.diningContentRow}>
                {/* Left Content Section */}
                <View style={styles.diningMainContent}>
                  <View style={styles.diningTopRow}>
                    <View style={styles.diningMealTypeChip}>
                      <Text style={styles.diningMealTypeIcon}>
                        {diningStop?.meal_type === 'breakfast' && 'ü•ê'}
                        {diningStop?.meal_type === 'brunch' && 'ü•û'}
                        {diningStop?.meal_type === 'coffee' && '‚òï'}
                        {diningStop?.meal_type === 'lunch' && 'üçΩÔ∏è'}
                        {diningStop?.meal_type === 'dinner' && 'üç∑'}
                        {diningStop?.meal_type === 'drinks' && 'üç∏'}
                      </Text>
                      <Text style={styles.diningMealTypeText}>
                        {diningStop?.meal_type?.charAt(0)?.toUpperCase()}{diningStop?.meal_type?.slice(1)}
                      </Text>
                    </View>
                  </View>
                  
                  <Text style={styles.diningStopName} numberOfLines={2}>{diningStop?.name}</Text>
                  <Text style={styles.diningStopAddress} numberOfLines={1}>{diningStop?.address}</Text>
                  
                  <View style={styles.diningRatingRow}>
                    <Text style={styles.diningRatingValue}>‚≠ê {diningStop?.rating?.toFixed(1)}</Text>
                    {diningStop?.price_level && (
                      <Text style={styles.diningPriceValue}>
                        {'$'.repeat(diningStop?.price_level)}
                      </Text>
                    )}
                  </View>
                  
                  <View style={styles.diningMetricsRowFixed}>
                    <View style={styles.diningTimeChip}>
                      <Text style={styles.diningTimeIcon}>üïê</Text>
                      <Text style={styles.diningTimeText}>
                        {diningStop?.arrival_time || 'TBD'} - {diningStop?.departure_time || 'TBD'}
                      </Text>
                    </View>
                    <View style={styles.diningDurationChip}>
                      <Text style={styles.diningDurationIcon}>üçΩÔ∏è</Text>
                      <Text style={styles.diningDurationText}>
                        {DiningService.formatDuration(diningStop?.dining_duration)}
                      </Text>
                    </View>
                  </View>
                  
                  {/* Reserve Button - Inside the card */}
                  <TouchableOpacity
                    style={styles.reserveButtonInside}
                    onPress={() => handleDiningReservation(diningStop)}
                    activeOpacity={0.7}
                  >
                    <Text style={styles.reserveButtonIcon}>üìû</Text>
                    <Text style={styles.reserveButtonText}>RESERVE</Text>
                  </TouchableOpacity>
                </View>
                
                {/* Right Image Section - Small */}
                <View style={styles.diningImageContainer}>
                  <PlaceImage 
                    place={diningStop} 
                    width={80} 
                    height={80} 
                    borderRadius={12}
                    resizeMode="cover"
                  />
                </View>
              </View>
              
              {/* Edit Button - Bottom */}
              <TouchableOpacity
                style={styles.editDiningButton}
                onPress={() => handleDiningStopEdit(diningStop, 0, diningIndex)}
                activeOpacity={0.7}
              >
                <Text style={styles.editIndicatorText}>‚úèÔ∏è Tap to edit</Text>
              </TouchableOpacity>
            </View>

            {/* Compact Travel + Add Food Stop Row */}
            <View style={styles.compactTravelRow}>
              {(() => {
                const walkingTime = diningStop?.travel_breakdown?.travelFromOptions?.walking?.duration || 999;
                const drivingTime = diningStop?.travel_breakdown?.travelFromOptions?.driving?.duration || 0;
                const shouldShowDual = walkingTime <= 25 && drivingTime >= 1;
                const rideId = generateRideId(diningStop?.name, currentItinerary?.places?.[0]?.name, 'first_dining_from');
                
                // DEBUG: Log dining stop travel options
                console.log(`üçΩÔ∏è Dining stop travel debug for ${diningStop?.name}:`, {
                  hasBreakdown: !!diningStop?.travel_breakdown,
                  hasTravelFromOptions: !!diningStop?.travel_breakdown?.travelFromOptions,
                  walkingTime,
                  drivingTime,
                  shouldShowDual,
                  walkingEligible: walkingTime <= 25,
                  drivingEligible: drivingTime >= 1,
                  rawBreakdown: diningStop?.travel_breakdown
                });
                
                if (shouldShowDual && diningStop?.travel_breakdown?.travelFromOptions) {
                  const travelOptions = {
                    walking: {
                      duration: walkingTime,
                      distance: Math.round((diningStop?.detour_distance || 1000) * 1.3), // Estimate walking distance
                      icon: diningStop?.travel_breakdown?.travelFromOptions?.walking?.icon,
                    },
                    driving: {
                      duration: drivingTime,
                      distance: diningStop?.detour_distance || 1000,
                      icon: diningStop?.travel_breakdown?.travelFromOptions?.driving?.icon,
                    },
                    rideId,
                    fromLocation: diningStop?.address,
                    toLocation: currentItinerary?.places?.[0]?.address,
                    fromCoordinates: diningStop?.coordinates,
                    toCoordinates: currentItinerary?.places?.[0]?.coordinates,
                  };
                  
                  const selectedMode = travelModes[rideId] || (diningStop?.travel_breakdown?.travel_from_mode === 'walking' ? 'walking' : 'driving');
                  
                  return (
                    <DualTravelIndicator
                      travelOptions={travelOptions}
                      selectedMode={selectedMode}
                      onModeChange={(newMode) => {
                        console.log(`üö∂/üöó Dining stop travel mode changed to: ${newMode} for ${rideId}`);
                        handleDiningStopTravelModeChange(rideId, newMode, diningIndex, 0, 'from');
                      }}
                      onRideBookPress={() => handleTravelSegmentPress(
                        diningStop?.address,
                        currentItinerary?.places?.[0]?.address,
                        diningStop?.coordinates,
                        currentItinerary?.places?.[0]?.coordinates,
                        diningStop?.detour_distance || 1000,
                        drivingTime,
                        rideId,
                        diningStop?.departure_time
                      )}
                      isRideBooked={rideBookings.some(ride => ride.id === rideId)}
                      canBookRide={drivingTime >= 1}
                      scheduledTime={diningStop?.departure_time}
                      day={isMultiDay ? activeDay : undefined}
                    />
                  );
                }
                
                // Fallback to regular TravelIndicator
                return (
                  <TravelIndicator
                    travelTime={diningStop?.travel_breakdown?.travel_from_restaurant || 0}
                    travelIcon={diningStop?.travel_breakdown?.travel_from_icon || 'üöó'}
                    fromLocation={diningStop?.address}
                    toLocation={currentItinerary?.places?.[0]?.address}
                    fromCoordinates={diningStop?.coordinates}
                    toCoordinates={currentItinerary?.places?.[0]?.coordinates}
                    distance={diningStop?.detour_distance || 1000}
                    rideId={rideId}
                    onPress={() => handleTravelSegmentPress(
                      diningStop?.address,
                      currentItinerary?.places?.[0]?.address,
                      diningStop?.coordinates,
                      currentItinerary?.places?.[0]?.coordinates,
                      diningStop?.detour_distance || 1000,
                      diningStop?.travel_breakdown?.travel_from_restaurant || 0,
                      rideId,
                      diningStop?.departure_time
                    )}
                    isRideBooked={rideBookings.some(ride => ride.id === rideId)}
                    canBookRide={(diningStop?.travel_breakdown?.travel_from_restaurant || 0) >= 1}
                    scheduledTime={diningStop?.departure_time}
                    day={isMultiDay ? activeDay : undefined}
                  />
                );
              })()}
              <TouchableOpacity 
                style={styles.circularAddFoodButton}
                onPress={() => handleDiningStopPress(-1, 0)}
                activeOpacity={0.7}
              >
                <Text style={styles.circularAddFoodIcon}>+</Text>
              </TouchableOpacity>
            </View>
          </View>
        );
        })}


        {currentItinerary?.places?.map((place, index) => (
          <View key={place?.place_id}>
            {/* Travel Time Block (for all places including first) */}
            {renderTravelTimeBlock(place, index)}
            
            {/* Place Card */}
            {renderPlaceCard(place, index)}
            

            {/* Render existing dining stops with travel segments */}
            {currentItinerary?.schedule?.[index + 1]?.diningStops?.map((diningStop, diningIndex) => {
              // Dining debug map
              return (
              <View key={`${diningStop?.place_id}-${diningIndex}`}>
                {/* Compact Travel Indicators Row */}
                <View style={styles.compactTravelRow}>
                  {(() => {
                    const walkingTime = diningStop?.travel_breakdown?.travelToOptions?.walking?.duration || 999;
                    const drivingTime = diningStop?.travel_breakdown?.travelToOptions?.driving?.duration || 0;
                    const shouldShowDual = walkingTime <= 25 && drivingTime >= 1;
                    const rideId = generateRideId(currentItinerary?.places?.[index]?.name, diningStop?.name, `${index}_${diningIndex}_to`);
                    
                    if (shouldShowDual && diningStop?.travel_breakdown?.travelToOptions) {
                      const travelOptions = {
                        walking: {
                          duration: walkingTime,
                          distance: Math.round((diningStop?.detour_distance || 1000) * 1.3),
                          icon: diningStop?.travel_breakdown?.travelToOptions?.walking?.icon,
                        },
                        driving: {
                          duration: drivingTime,
                          distance: diningStop?.detour_distance || 1000,
                          icon: diningStop?.travel_breakdown?.travelToOptions?.driving?.icon,
                        },
                        rideId,
                        fromLocation: currentItinerary?.places?.[index]?.address,
                        toLocation: diningStop?.address,
                        fromCoordinates: currentItinerary?.places?.[index]?.coordinates,
                        toCoordinates: diningStop?.coordinates,
                      };
                      
                      const selectedMode = travelModes[rideId] || (diningStop?.travel_breakdown?.travel_to_mode === 'walking' ? 'walking' : 'driving');
                      
                      return (
                        <DualTravelIndicator
                          travelOptions={travelOptions}
                          selectedMode={selectedMode}
                          onModeChange={(newMode) => {
                            console.log(`üö∂/üöó Dining stop travel mode changed to: ${newMode} for ${rideId}`);
                            handleDiningStopTravelModeChange(rideId, newMode, diningIndex, index + 1, 'to');
                          }}
                          isRideBooked={rideBookings.some(ride => ride.id === rideId)}
                          canBookRide={drivingTime >= 1}
                          scheduledTime={diningStop?.arrival_time}
                          day={isMultiDay ? activeDay : undefined}
                        />
                      );
                    }
                    
                    return (
                      <TravelIndicator
                        travelTime={diningStop?.travel_breakdown?.travel_to_restaurant || 0}
                        travelIcon={diningStop?.travel_breakdown?.travel_to_icon || 'üöó'}
                        fromLocation={currentItinerary?.places?.[index]?.address}
                        toLocation={diningStop?.address}
                        fromCoordinates={currentItinerary?.places?.[index]?.coordinates}
                        toCoordinates={diningStop?.coordinates}
                        distance={diningStop?.detour_distance || 1000}
                        rideId={rideId}
                        onPress={() => handleTravelSegmentPress(
                          currentItinerary?.places?.[index]?.address,
                          diningStop?.address,
                          currentItinerary?.places?.[index]?.coordinates,
                          diningStop?.coordinates,
                          diningStop?.detour_distance || 1000,
                          diningStop?.travel_breakdown?.travel_to_restaurant || 0,
                          rideId,
                          diningStop?.arrival_time
                        )}
                        isRideBooked={rideBookings.some(ride => ride.id === rideId)}
                        canBookRide={(diningStop?.travel_breakdown?.travel_to_restaurant || 0) >= 1}
                        scheduledTime={diningStop?.arrival_time}
                        day={isMultiDay ? activeDay : undefined}
                      />
                    );
                  })()}
                </View>

                {/* Restaurant/Dining Stop */}
                <TouchableOpacity
                  style={styles.diningStopCard}
                  onPress={() => handleDiningStopEdit(diningStop, index + 1, diningIndex)}
                  activeOpacity={0.8}
                >
                {/* Remove Button - Top Right */}
                <TouchableOpacity 
                  style={styles.removeDiningButton}
                  onPress={() => {
                    // Check if this is a return dining stop (extra schedule item)
                    if (index + 1 === currentItinerary?.places?.length) {
                      removeReturnDiningStop();
                    } else {
                      handleRemoveDiningStop(diningStop, index + 1, diningIndex);
                    }
                  }}
                  activeOpacity={0.7}
                >
                  <Text style={styles.removeDiningIcon}>√ó</Text>
                </TouchableOpacity>

                {/* Horizontal Layout - Text Left, Image Right */}
                <View style={styles.diningContentRow}>
                  {/* Left Content Section */}
                  <View style={styles.diningMainContent}>
                    <View style={styles.diningTopRow}>
                      <View style={styles.diningMealTypeChip}>
                        <Text style={styles.diningMealTypeIcon}>
                          {diningStop?.meal_type === 'breakfast' && 'ü•ê'}
                          {diningStop?.meal_type === 'brunch' && 'ü•û'}
                          {diningStop?.meal_type === 'coffee' && '‚òï'}
                          {diningStop?.meal_type === 'lunch' && 'üçΩÔ∏è'}
                          {diningStop?.meal_type === 'dinner' && 'üç∑'}
                          {diningStop?.meal_type === 'drinks' && 'üç∏'}
                        </Text>
                        <Text style={styles.diningMealTypeText}>
                          {diningStop?.meal_type?.charAt(0)?.toUpperCase()}{diningStop?.meal_type?.slice(1)}
                        </Text>
                      </View>
                    </View>
                    
                    <Text style={styles.diningStopName} numberOfLines={2}>{diningStop?.name}</Text>
                    <Text style={styles.diningStopAddress} numberOfLines={1}>{diningStop?.address}</Text>
                    
                    <View style={styles.diningRatingRow}>
                      <Text style={styles.diningRatingValue}>‚≠ê {diningStop?.rating?.toFixed(1)}</Text>
                      {diningStop?.price_level && (
                        <Text style={styles.diningPriceValue}>
                          {'$'.repeat(diningStop?.price_level)}
                        </Text>
                      )}
                    </View>
                    
                    <View style={styles.diningMetricsRowFixed}>
                      <View style={styles.diningTimeChip}>
                        <Text style={styles.diningTimeIcon}>üïê</Text>
                        <Text style={styles.diningTimeText}>
                          {diningStop?.arrival_time || 'TBD'} - {diningStop?.departure_time || 'TBD'}
                        </Text>
                      </View>
                      <View style={styles.diningDurationChip}>
                        <Text style={styles.diningDurationIcon}>üçΩÔ∏è</Text>
                        <Text style={styles.diningDurationText}>
                          {DiningService.formatDuration(diningStop?.dining_duration)}
                        </Text>
                      </View>
                    </View>
                    
                    {/* Reserve Button - Inside the card */}
                    <TouchableOpacity
                      style={styles.reserveButtonInside}
                      onPress={(e) => {
                        e.stopPropagation(); // Prevent parent TouchableOpacity from handling the press
                        handleDiningReservation(diningStop);
                      }}
                      activeOpacity={0.7}
                    >
                      <Text style={styles.reserveButtonIcon}>üìû</Text>
                      <Text style={styles.reserveButtonText}>RESERVE</Text>
                    </TouchableOpacity>
                  </View>
                  
                  {/* Right Image Section - Small */}
                  <View style={styles.diningImageContainer}>
                    <PlaceImage 
                      place={diningStop} 
                      width={80} 
                      height={80} 
                      borderRadius={12}
                      resizeMode="cover"
                    />
                  </View>
                </View>
                <View style={styles.editIndicator}>
                  <Text style={styles.editIndicatorText}>‚úèÔ∏è Tap to edit</Text>
                </View>
                </TouchableOpacity>

                {/* Compact Travel + Add Food Stop Row */}
                <View style={styles.compactTravelRow}>
                  {(() => {
                    const walkingTime = diningStop?.travel_breakdown?.travelFromOptions?.walking?.duration || 999;
                    const drivingTime = diningStop?.travel_breakdown?.travelFromOptions?.driving?.duration || 0;
                    const shouldShowDual = walkingTime <= 25 && drivingTime >= 1;
                    const rideId = generateRideId(diningStop?.name, index + 1 < currentItinerary?.places?.length ? currentItinerary?.places?.[index + 1]?.name : 'return', `${index}_${diningIndex}_from`);
                    
                    if (shouldShowDual && diningStop?.travel_breakdown?.travelFromOptions) {
                      const travelOptions = {
                        walking: {
                          duration: walkingTime,
                          distance: Math.round((diningStop?.detour_distance || 1000) * 1.3),
                          icon: diningStop?.travel_breakdown?.travelFromOptions?.walking?.icon,
                        },
                        driving: {
                          duration: drivingTime,
                          distance: diningStop?.detour_distance || 1000,
                          icon: diningStop?.travel_breakdown?.travelFromOptions?.driving?.icon,
                        },
                        rideId,
                        fromLocation: diningStop?.address,
                        toLocation: index + 1 < currentItinerary?.places?.length ? currentItinerary?.places?.[index + 1]?.address : (returnLocation?.address || startingLocation?.address),
                        fromCoordinates: diningStop?.coordinates,
                        toCoordinates: index + 1 < currentItinerary?.places?.length ? currentItinerary?.places?.[index + 1]?.coordinates : (returnLocation?.coordinates || startingLocation?.coordinates),
                      };
                      
                      const selectedMode = travelModes[rideId] || (diningStop?.travel_breakdown?.travel_from_mode === 'walking' ? 'walking' : 'driving');
                      
                      return (
                        <DualTravelIndicator
                          travelOptions={travelOptions}
                          selectedMode={selectedMode}
                          onModeChange={(newMode) => {
                            console.log(`üö∂/üöó Dining stop travel mode changed to: ${newMode} for ${rideId}`);
                            handleDiningStopTravelModeChange(rideId, newMode, diningIndex, index + 1, 'from');
                          }}
                          isRideBooked={rideBookings.some(ride => ride.id === rideId)}
                          canBookRide={drivingTime >= 1}
                          scheduledTime={diningStop?.departure_time}
                          day={isMultiDay ? activeDay : undefined}
                        />
                      );
                    }
                    
                    return (
                      <TravelIndicator
                        travelTime={diningStop?.travel_breakdown?.travel_from_restaurant || 0}
                        travelIcon={diningStop?.travel_breakdown?.travel_from_icon || 'üöó'}
                        fromLocation={diningStop?.address}
                        toLocation={index + 1 < currentItinerary?.places?.length ? currentItinerary?.places?.[index + 1]?.address : (returnLocation?.address || startingLocation?.address)}
                        fromCoordinates={diningStop?.coordinates}
                        toCoordinates={index + 1 < currentItinerary?.places?.length ? currentItinerary?.places?.[index + 1]?.coordinates : (returnLocation?.coordinates || startingLocation?.coordinates)}
                        distance={diningStop?.detour_distance || 1000}
                        rideId={rideId}
                        onPress={() => handleTravelSegmentPress(
                          diningStop?.address,
                          index + 1 < currentItinerary?.places?.length ? currentItinerary?.places?.[index + 1]?.address : (returnLocation?.address || startingLocation?.address),
                          diningStop?.coordinates,
                          index + 1 < currentItinerary?.places?.length ? currentItinerary?.places?.[index + 1]?.coordinates : (returnLocation?.coordinates || startingLocation?.coordinates),
                          diningStop?.detour_distance || 1000,
                          diningStop?.travel_breakdown?.travel_from_restaurant || 0,
                          rideId,
                          diningStop?.departure_time
                        )}
                        isRideBooked={rideBookings.some(ride => ride.id === rideId)}
                        canBookRide={(diningStop?.travel_breakdown?.travel_from_restaurant || 0) >= 1}
                        scheduledTime={diningStop?.departure_time}
                        day={isMultiDay ? activeDay : undefined}
                      />
                    );
                  })()}
                  <TouchableOpacity 
                    style={styles.circularAddFoodButton}
                    onPress={() => {
                      console.log(`üçΩÔ∏è + Button pressed between places ${index} and ${index + 1}`);
                      handleDiningStopPress(index, index + 1);
                    }}
                    activeOpacity={0.7}
                  >
                    <Text style={styles.circularAddFoodIcon}>+</Text>
                  </TouchableOpacity>
                </View>
              </View>
            );
            })}

          </View>
        ))}


        {/* Return Point - either different location or back to start */}
        {renderReturnTravelBlock()}
        <View style={styles.returnPointCard}>
          <View style={styles.returnPointHeader}>
            <View style={styles.returnPointIcon}>
              <Text style={styles.returnPointIconText}>
                {returnLocation ? 'üè†' : 'üèÅ'}
              </Text>
            </View>
            <View style={styles.returnPointInfo}>
              <Text style={styles.returnPointTitle}>
                {returnLocation ? 'Return Point' : 'Return to Start'}
              </Text>
              <Text style={styles.returnPointAddress}>
                {returnLocation?.address || startingLocation?.address}
              </Text>
              {(() => {
                // Calculate return time based on last place departure time + travel time
                const lastScheduleItem = currentItinerary?.schedule?.[currentItinerary?.schedule?.length - 1];
                if (lastScheduleItem) {
                  // Calculate return travel time using the same logic as renderReturnTravelBlock
                  const lastPlace = currentItinerary?.places?.[currentItinerary?.places?.length - 1];
                  const returnRideId = generateRideId(lastPlace?.name, 'return', 999);
                  const selectedReturnMode = travelModes[returnRideId] || 'driving';
                  const returnDisplayInfo = getTravelDisplayInfo(returnRideId, selectedReturnMode);
                  const returnTravelTime = returnDisplayInfo.duration || lastPlace?.returnTravelTime || 15;
                  
                  const departureTime = lastScheduleItem.departureTime;
                  
                  // Calculate return arrival time
                  const returnArrivalTime = addMinutesToTime(departureTime, returnTravelTime);
                  
                  return (
                    <Text style={styles.returnPointTime}>
                      Estimated arrival: {returnArrivalTime}
                    </Text>
                  );
                }
                return null;
              })()}
            </View>
          </View>
        </View>
      </View>

      {/* Toggle Buttons for Select All */}
      <View style={styles.toggleButtonsContainer}>
        <TouchableOpacity
          style={[
            styles.toggleButton,
            allTicketsSelected && styles.toggleButtonActiveTickets
          ]}
          onPress={handleToggleAllTickets}
          activeOpacity={0.7}
        >
          <View style={styles.toggleButtonContent}>
            <Text style={[
              styles.toggleButtonIcon,
              allTicketsSelected && styles.toggleButtonIconActive
            ]}>
              {allTicketsSelected ? 'üé´' : 'üéüÔ∏è'}
            </Text>
            <Text style={[
              styles.toggleButtonText,
              allTicketsSelected && styles.toggleButtonTextActive
            ]}>
              {allTicketsSelected ? '‚úì All Tickets' : '‚óã All Tickets'}
            </Text>
          </View>
        </TouchableOpacity>

        <TouchableOpacity
          style={[
            styles.toggleButton,
            allRidesSelected && styles.toggleButtonActiveRides
          ]}
          onPress={handleToggleAllRides}
          activeOpacity={0.7}
        >
          <View style={styles.toggleButtonContent}>
            <Text style={[
              styles.toggleButtonIcon,
              allRidesSelected && styles.toggleButtonIconActive
            ]}>
              {allRidesSelected ? 'üöó' : 'üöï'}
            </Text>
            <Text style={[
              styles.toggleButtonText,
              allRidesSelected && styles.toggleButtonTextActive
            ]}>
              {allRidesSelected ? '‚úì All Rides' : '‚óã All Rides'}
            </Text>
          </View>
        </TouchableOpacity>
      </View>
      
      {/* Bottom padding to prevent content from being hidden behind floating buttons */}
      <View style={{ height: 100 }} />

      {/* Dining Stop Selector Modal */}
      {selectedRouteSegment && (
        <DiningStopSelector
          visible={diningModalVisible}
          fromLocation={selectedRouteSegment.fromLocation}
          toLocation={selectedRouteSegment.toLocation}
          arrivalTime={selectedRouteSegment.arrivalTime}
          onDiningSelected={handleDiningSelected}
          onClose={() => {
            console.log('üçΩÔ∏è DiningStopSelector: Modal closing...');
            setDiningModalVisible(false);
            setSelectedRouteSegment(null);
          }}
        />
      )}

      {/* Dining Stop Editor Modal */}
      {editingDiningStop && (
        <DiningStopEditor
          visible={!!editingDiningStop}
          diningStop={editingDiningStop.stop}
          onClose={() => setEditingDiningStop(null)}
          onUpdate={handleDiningStopUpdate}
          onRemove={handleDiningStopRemove}
        />
      )}
      
      {/* Visit Duration Editing Modal */}
      <Modal
        visible={editingVisitDuration !== null}
        transparent={true}
        animationType="slide"
        onRequestClose={() => setEditingVisitDuration(null)}
      >
        <View style={styles.durationModalOverlay}>
          <View style={styles.durationModalContent}>
            <View style={styles.durationModalHeader}>
              <Text style={styles.durationModalTitle}>Edit Visit Duration</Text>
              <TouchableOpacity
                style={styles.durationModalClose}
                onPress={() => setEditingVisitDuration(null)}
              >
                <Text style={styles.durationModalCloseText}>‚úï</Text>
              </TouchableOpacity>
            </View>
            
            <Text style={styles.durationModalPlaceName}>
              {editingVisitDuration?.placeName}
            </Text>
            
            <View style={styles.durationInputContainer}>
              <Text style={styles.durationInputLabel}>Duration (minutes)</Text>
              <TextInput
                style={styles.durationInput}
                value={newVisitDuration}
                onChangeText={setNewVisitDuration}
                keyboardType="numeric"
                placeholder="Enter minutes"
                placeholderTextColor={Colors.text.tertiary}
                autoFocus={true}
              />
              <Text style={styles.durationInputHint}>
                Recommended: 30-180 minutes
              </Text>
            </View>
            
            <View style={styles.durationModalButtons}>
              <TouchableOpacity
                style={[styles.durationModalButton, styles.durationModalCancel]}
                onPress={() => setEditingVisitDuration(null)}
              >
                <Text style={styles.durationModalCancelText}>Cancel</Text>
              </TouchableOpacity>
              
              <TouchableOpacity
                style={[styles.durationModalButton, styles.durationModalSave]}
                onPress={handleVisitDurationUpdate}
              >
                <Text style={styles.durationModalSaveText}>Update Schedule</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>

      {/* Square Cards Detail Modals */}
      
      {/* Optimization Notes Modal */}
      <Modal
        visible={activeModal === 'optimization'}
        transparent={true}
        animationType="slide"
        onRequestClose={() => setActiveModal(null)}
      >
        <View style={styles.detailModalOverlay}>
          <View style={styles.detailModalContent}>
            <View style={styles.detailModalHeader}>
              <Text style={styles.detailModalIcon}>üí°</Text>
              <Text style={styles.detailModalTitle}>Optimization Notes</Text>
              <TouchableOpacity
                style={styles.detailModalClose}
                onPress={() => setActiveModal(null)}
              >
                <Text style={styles.detailModalCloseText}>‚úï</Text>
              </TouchableOpacity>
            </View>
            
            <ScrollView style={styles.detailModalScroll} showsVerticalScrollIndicator={false}>
              {currentItinerary.optimizationNotes?.map((note, index) => (
                <View key={index} style={styles.detailModalItem}>
                  <Text style={styles.detailModalBullet}>‚Ä¢</Text>
                  <Text style={styles.detailModalText}>{note}</Text>
                </View>
              ))}
            </ScrollView>
          </View>
        </View>
      </Modal>

      {/* Missed Interests Modal */}
      <Modal
        visible={activeModal === 'missed'}
        transparent={true}
        animationType="slide"
        onRequestClose={() => setActiveModal(null)}
      >
        <View style={styles.detailModalOverlay}>
          <View style={styles.detailModalContent}>
            <View style={styles.detailModalHeader}>
              <Text style={styles.detailModalIcon}>‚ö†Ô∏è</Text>
              <Text style={styles.detailModalTitle}>Missed Interests</Text>
              <TouchableOpacity
                style={styles.detailModalClose}
                onPress={() => setActiveModal(null)}
              >
                <Text style={styles.detailModalCloseText}>‚úï</Text>
              </TouchableOpacity>
            </View>
            
            <ScrollView style={styles.detailModalScroll} showsVerticalScrollIndicator={false}>
              {currentItinerary.uncoveredInterests?.map((interest, index) => (
                <View key={index} style={styles.detailModalItem}>
                  <Text style={styles.detailModalBullet}>‚Ä¢</Text>
                  <Text style={styles.detailModalText}>{interest}</Text>
                </View>
              ))}
            </ScrollView>
            
            <Text style={styles.detailModalFooter}>
              These interests couldn't be covered due to time constraints or location limits.
            </Text>
          </View>
        </View>
      </Modal>

      {/* Popular Places Modal */}
      <Modal
        visible={activeModal === 'popular'}
        transparent={true}
        animationType="slide"
        onRequestClose={() => setActiveModal(null)}
      >
        <View style={styles.detailModalOverlay}>
          <View style={styles.detailModalContent}>
            <View style={styles.detailModalHeader}>
              <Text style={styles.detailModalIcon}>üåü</Text>
              <Text style={styles.detailModalTitle}>Popular Places You're Missing</Text>
              <TouchableOpacity
                style={styles.detailModalClose}
                onPress={() => setActiveModal(null)}
              >
                <Text style={styles.detailModalCloseText}>‚úï</Text>
              </TouchableOpacity>
            </View>
            
            <ScrollView style={styles.detailModalScroll} showsVerticalScrollIndicator={false}>
              {currentItinerary.missedPopularPlaces?.map((missed, index) => (
                <View key={index} style={styles.popularPlaceItem}>
                  <Text style={styles.popularPlaceName}>{missed.place.name}</Text>
                  <Text style={styles.popularPlaceRating}>
                    ‚≠ê {missed.place.rating} ‚Ä¢ {(missed.place.user_ratings_total || 0).toLocaleString()} reviews
                  </Text>
                  <Text style={styles.popularPlaceReason}>{missed.reason}</Text>
                </View>
              ))}
            </ScrollView>
          </View>
        </View>
      </Modal>

      {/* Dining Stops Modal */}
      <Modal
        visible={activeModal === 'dining'}
        transparent={true}
        animationType="slide"
        onRequestClose={() => setActiveModal(null)}
      >
        <View style={styles.detailModalOverlay}>
          <View style={styles.detailModalContent}>
            <View style={styles.detailModalHeader}>
              <Text style={styles.detailModalIcon}>üçΩÔ∏è</Text>
              <Text style={styles.detailModalTitle}>Dining Breakdown</Text>
              <TouchableOpacity
                style={styles.detailModalClose}
                onPress={() => setActiveModal(null)}
              >
                <Text style={styles.detailModalCloseText}>‚úï</Text>
              </TouchableOpacity>
            </View>
            
            <ScrollView style={styles.detailModalScroll} showsVerticalScrollIndicator={false}>
              {(() => {
                const diningStats = getDiningStopStats();
                return Object.entries(diningStats.mealTypes).map(([mealType, count]) => (
                  <View key={mealType} style={styles.diningTypeItem}>
                    <Text style={styles.diningTypeEmoji}>
                      {mealType === 'breakfast' && 'ü•ê'}
                      {mealType === 'brunch' && 'ü•û'}
                      {mealType === 'coffee' && '‚òï'}
                      {mealType === 'lunch' && 'üçΩÔ∏è'}
                      {mealType === 'dinner' && 'üç∑'}
                      {mealType === 'drinks' && 'üç∏'}
                    </Text>
                    <Text style={styles.diningTypeText}>
                      {mealType.charAt(0).toUpperCase() + mealType.slice(1)}
                    </Text>
                    <Text style={styles.diningTypeCount}>{count}</Text>
                  </View>
                ));
              })()}
              
              {(() => {
                const diningStats = getDiningStopStats();
                return (
                  <View style={styles.diningStatsContainer}>
                    <Text style={styles.diningStatsTitle}>Summary</Text>
                    <Text style={styles.diningStatsText}>Total Stops: {diningStats.totalStops}</Text>
                    <Text style={styles.diningStatsText}>Total Time: {diningStats.formattedTime}</Text>
                  </View>
                );
              })()}
            </ScrollView>
          </View>
        </View>
      </Modal>

      {/* Place Change Selector */}
      {changingPlace && (
        <PlaceChangeSelector
          visible={changingPlace !== null}
          onClose={() => setChangingPlace(null)}
          currentPlace={changingPlace.place}
          alternatives={changingPlace.alternatives}
          visitTime={changingPlace.visitTime}
          visitDate={changingPlace.visitDate}
          onPlaceSelected={handlePlaceReplace}
          loading={loadingAlternatives}
          currentItinerary={currentItinerary}
        />
      )}

      {/* Checkout Modal */}
      <Modal
        visible={showCheckout}
        animationType="slide"
        presentationStyle="pageSheet"
      >
        <CheckoutPage
          bookingInfo={bookingInfo}
          itinerary={itinerary}
          startingLocation={startingLocation}
          returnLocation={returnLocation}
          onConfirmBooking={handleConfirmBooking}
          onBack={() => setShowCheckout(false)}
        />
      </Modal>

      {/* Booking Confirmation Modal */}
      <Modal
        visible={showConfirmation}
        animationType="slide"
        presentationStyle="pageSheet"
      >
        <BookingConfirmationPage
          itinerary={itinerary}
          bookingInfo={bookingInfo}
          startingLocation={startingLocation}
          returnLocation={returnLocation}
          onBackToHome={handleBackToHome}
          onViewItinerary={handleViewItinerary}
        />
      </Modal>

      {/* Print Itinerary Modal */}
      <Modal
        visible={showPrintItinerary}
        animationType="slide"
        presentationStyle="pageSheet"
      >
        <PrintItinerary
          itinerary={itinerary}
          bookingInfo={bookingInfo}
          startingLocation={startingLocation}
          returnLocation={returnLocation || startingLocation}
          onClose={() => setShowPrintItinerary(false)}
        />
      </Modal>

      {/* Reservation Modal */}
      <Modal
        visible={showReservationModal}
        animationType="slide"
        transparent={false}
        statusBarTranslucent={false}
        onShow={() => console.log('üîî Modal onShow triggered')}
        onRequestClose={() => {
          console.log('üîî Modal onRequestClose triggered');
          setShowReservationModal(false);
          setSelectedDiningStop(null);
        }}
      >
        <ReservationModal
          diningStop={selectedDiningStop}
          onClose={() => {
            console.log('üîî Modal onClose triggered');
            setShowReservationModal(false);
            setSelectedDiningStop(null);
          }}
        />
      </Modal>

      {/* Ride Selection Modal */}
      {selectedRideSegment && (
        <RideSelectionModal
          visible={showRideModal}
          onClose={() => {
            setShowRideModal(false);
            setSelectedRideSegment(null);
          }}
          fromLocation={selectedRideSegment.fromLocation}
          toLocation={selectedRideSegment.toLocation}
          fromCoordinates={selectedRideSegment.fromCoordinates}
          toCoordinates={selectedRideSegment.toCoordinates}
          distance={selectedRideSegment.distance}
          estimatedDuration={selectedRideSegment.estimatedDuration}
          rideId={selectedRideSegment.rideId}
          scheduledTime={selectedRideSegment.scheduledTime}
          day={isMultiDay ? activeDay : undefined}
          onRideSelect={handleRideSelect}
          onRideRemove={handleRideRemove}
          currentBooking={rideBookings.find(ride => ride.id === selectedRideSegment.rideId)}
        />
      )}

      {/* Debug Panel - Hidden for production */}
      {/* <TouchableOpacity
        style={styles.debugToggleButton}
        onPress={() => setShowDebugPanel(!showDebugPanel)}
      >
        <Text style={styles.debugToggleText}>üîç Debug</Text>
      </TouchableOpacity>

      {showDebugPanel && (
        <View style={styles.debugPanel}>
          <View style={styles.debugHeader}>
            <Text style={styles.debugTitle}>Debug Logger</Text>
            <TouchableOpacity
              style={styles.debugCloseButton}
              onPress={() => setShowDebugPanel(false)}
            >
              <Text style={styles.debugCloseText}>√ó</Text>
            </TouchableOpacity>
          </View>
          
          <View style={styles.debugControls}>
            <TouchableOpacity
              style={[styles.debugButton, isDebugLogging && styles.debugButtonActive]}
              onPress={isDebugLogging ? stopDebugLogging : startDebugLogging}
            >
              <Text style={styles.debugButtonText}>
                {isDebugLogging ? '‚èπ Stop' : '‚ñ∂ Start'} Logging
              </Text>
            </TouchableOpacity>
            
            <TouchableOpacity
              style={styles.debugButton}
              onPress={clearDebugLogs}
            >
              <Text style={styles.debugButtonText}>üóëÔ∏è Clear</Text>
            </TouchableOpacity>
            
            <TouchableOpacity
              style={styles.debugButton}
              onPress={exportDebugLogs}
            >
              <Text style={styles.debugButtonText}>üìÑ Export</Text>
            </TouchableOpacity>
          </View>
          
          <ScrollView style={styles.debugLogContainer} nestedScrollEnabled={true}>
            <Text style={styles.debugLogText}>
              {debugLogContent || 'No debug logs captured yet. Start logging to capture travel mode selection and schedule calculation details.'}
            </Text>
          </ScrollView>
        </View>
      )} */}
      </ScrollView>
      
      {/* Floating Action Buttons - Fixed at bottom */}
      <View style={styles.floatingActionContainer}>
        <TouchableOpacity style={styles.floatingPrintButton} onPress={handlePrintItinerary}>
          <Text style={styles.floatingPrintButtonText}>üìÑ</Text>
        </TouchableOpacity>
        <TouchableOpacity 
          style={[styles.floatingCheckoutButton, bookingInfo.totalCost === 0 && styles.disabledFloatingCheckoutButton]} 
          onPress={handleCheckout}
          disabled={bookingInfo.totalCost === 0}
        >
          <Text style={styles.floatingCheckoutButtonText}>
            üí≥ {bookingInfo.totalCost > 0 ? `$${bookingInfo.totalCost.toFixed(2)}` : 'Checkout'}
          </Text>
        </TouchableOpacity>
      </View>
    </View>
  );
};

// Professional Dark Theme Color System - Using imported Colors

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.background.primary,
  },
  stickyHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 24,
    paddingVertical: 12,
    paddingTop: 12,
    backgroundColor: Colors.glass,
    borderBottomWidth: 1,
    borderBottomColor: Colors.glassBorder,
    backdropFilter: 'blur(20px)',
    position: 'relative',
    zIndex: 1000,
  },
  scrollableContent: {
    flex: 1,
    backgroundColor: Colors.background.primary,
  },
  headerSpacer: {
    width: 48, // Same width as back button for balance
  },
  backButton: {
    padding: 12,
    borderRadius: 12,
    backgroundColor: Colors.background.tertiary,
    borderWidth: 1,
    borderColor: Colors.glassBorder,
  },
  backButtonText: {
    fontSize: 16,
    color: Colors.primary,
    fontWeight: '600',
  },
  headerTitle: {
    fontSize: 22,
    fontWeight: '700',
    color: Colors.text.primary,
    letterSpacing: 0.5,
  },
  
  // Toggle buttons styles
  toggleButtonsContainer: {
    flexDirection: 'row',
    paddingHorizontal: 20,
    paddingVertical: 16,
    gap: 12,
    backgroundColor: Colors.background.primary,
  },
  toggleButton: {
    flex: 1,
    paddingVertical: 14,
    paddingHorizontal: 16,
    borderRadius: 16,
    borderWidth: 2,
    borderColor: Colors.glassBorder,
    backgroundColor: Colors.background.secondary,
    alignItems: 'center',
    justifyContent: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  toggleButtonActiveTickets: {
    backgroundColor: '#FF6B6B',
    borderColor: '#FF6B6B',
    shadowColor: '#FF6B6B',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 8,
    elevation: 6,
  },
  toggleButtonActiveRides: {
    backgroundColor: '#4ECDC4',
    borderColor: '#4ECDC4',
    shadowColor: '#4ECDC4',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 8,
    elevation: 6,
  },
  toggleButtonContent: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  toggleButtonIcon: {
    fontSize: 20,
    textShadowColor: 'rgba(0, 0, 0, 0.1)',
    textShadowOffset: { width: 0, height: 1 },
    textShadowRadius: 2,
  },
  toggleButtonIconActive: {
    textShadowColor: 'rgba(255, 255, 255, 0.3)',
    textShadowOffset: { width: 0, height: 1 },
    textShadowRadius: 2,
  },
  toggleButtonText: {
    fontSize: 16,
    fontWeight: '600',
    color: Colors.text.primary,
  },
  toggleButtonTextActive: {
    color: Colors.background.primary,
    textShadowColor: 'rgba(0, 0, 0, 0.1)',
    textShadowOffset: { width: 0, height: 1 },
    textShadowRadius: 2,
  },
  
  mapContainer: {
    height: height * 0.3,
    marginHorizontal: 24,
    marginVertical: 16,
    borderRadius: 20,
    overflow: 'hidden',
    backgroundColor: Colors.background.secondary,
    borderWidth: 1,
    borderColor: Colors.glassBorder,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 8 },
    shadowOpacity: 0.3,
    shadowRadius: 16,
    elevation: 8,
  },
  map: {
    flex: 1,
  },
  zoomControls: {
    position: 'absolute',
    bottom: 20,
    right: 20,
    flexDirection: 'column',
  },
  zoomButton: {
    backgroundColor: Colors.background.secondary,
    borderWidth: 1,
    borderColor: Colors.glassBorder,
    borderRadius: 25,
    width: 50,
    height: 50,
    alignItems: 'center',
    justifyContent: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.3,
    shadowRadius: 4,
    elevation: 4,
    marginBottom: 8,
  },
  zoomButtonText: {
    color: Colors.text.primary,
    fontSize: 24,
    fontWeight: 'bold',
    lineHeight: 24,
  },
  markerContainer: {
    backgroundColor: '#e74c3c',
    borderRadius: 15,
    width: 30,
    height: 30,
    alignItems: 'center',
    justifyContent: 'center',
    borderWidth: 2,
    borderColor: 'white',
  },
  markerText: {
    color: 'white',
    fontWeight: 'bold',
    fontSize: 14,
  },
  startMarkerContainer: {
    backgroundColor: '#27ae60',
    borderRadius: 20,
    width: 40,
    height: 40,
    alignItems: 'center',
    justifyContent: 'center',
    borderWidth: 3,
    borderColor: 'white',
  },
  startMarkerText: {
    fontSize: 18,
  },
  returnMarkerContainer: {
    backgroundColor: '#e74c3c',
    borderRadius: 20,
    width: 40,
    height: 40,
    alignItems: 'center',
    justifyContent: 'center',
    borderWidth: 3,
    borderColor: 'white',
  },
  returnMarkerText: {
    fontSize: 18,
  },
  summaryCard: {
    backgroundColor: Colors.background.secondary,
    marginHorizontal: 20,
    marginVertical: 10,
    padding: 18,
    borderRadius: 16,
    borderWidth: 1,
    borderColor: Colors.glassBorder,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 6 },
    shadowOpacity: 0.2,
    shadowRadius: 12,
    elevation: 6,
  },
  summaryTitle: {
    fontSize: 17,
    fontWeight: '700',
    color: Colors.text.primary,
    marginBottom: 16,
    letterSpacing: 0.3,
  },
  summaryRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 10,
    paddingVertical: 3,
  },
  summaryLabel: {
    fontSize: 14,
    color: Colors.text.secondary,
    fontWeight: '500',
  },
  summaryValue: {
    fontSize: 14,
    fontWeight: '600',
    color: Colors.text.primary,
  },
  totalDurationHighlight: {
    color: Colors.primary,
    fontWeight: '700',
    fontSize: 16,
  },
  travelBreakdownContainer: {
    marginTop: 20,
    padding: 16,
    backgroundColor: Colors.background.tertiary,
    borderRadius: 16,
    borderLeftWidth: 4,
    borderLeftColor: Colors.success,
  },
  // Removed - using compact card design instead
  notesContainer: {
    marginTop: 20,
    padding: 16,
    backgroundColor: Colors.background.tertiary,
    borderRadius: 16,
    borderLeftWidth: 4,
    borderLeftColor: Colors.secondary,
  },
  notesTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: Colors.secondary,
    marginBottom: 12,
    letterSpacing: 0.3,
  },
  noteText: {
    fontSize: 14,
    color: Colors.text.secondary,
    marginBottom: 6,
    lineHeight: 20,
  },
  placesContainer: {
    marginTop: 8,
    marginBottom: 8,
    paddingHorizontal: 8,
  },
  placesTitle: {
    fontSize: 14,
    fontWeight: '700',
    color: Colors.text.primary,
    marginBottom: 6,
  },
  placeCard: {
    backgroundColor: Colors.background.card,
    borderRadius: 10,
    padding: 10,
    marginBottom: 8,
    borderWidth: 1,
    borderColor: Colors.glassBorder,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.08,
    shadowRadius: 4,
    elevation: 1,
  },
  placeHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 6,
  },
  placeNumber: {
    backgroundColor: Colors.primary,
    borderRadius: 20,
    width: 44,
    height: 44,
    alignItems: 'center',
    justifyContent: 'center',
    marginRight: 6,
    shadowColor: Colors.primary,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 8,
    elevation: 6,
  },
  placeNumberText: {
    color: Colors.background.primary,
    fontWeight: '700',
    fontSize: 16,
  },
  placeInfo: {
    flex: 1,
    marginRight: 6,
  },
  placeName: {
    fontSize: 13,
    fontWeight: '700',
    color: Colors.text.primary,
    marginBottom: 2,
  },
  placeAddress: {
    fontSize: 11,
    color: Colors.text.secondary,
    marginBottom: 2,
  },
  placeDetails: {
    flexDirection: 'row',
    gap: 15,
  },
  rating: {
    fontSize: 14,
    color: Colors.warning,
    fontWeight: '600',
  },
  price: {
    fontSize: 14,
    color: Colors.error,
    fontWeight: '600',
  },
  scheduleInfo: {
    marginTop: 6,
    padding: 6,
    backgroundColor: Colors.background.tertiary,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: Colors.glassBorder,
  },
  scheduleRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
  },
  scheduleLeft: {
    flex: 1,
    marginRight: 12,
  },
  scheduleText: {
    fontSize: 11,
    fontWeight: '600',
    color: Colors.text.primary,
  },
  visitInfoRow: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: 2,
    flexWrap: 'wrap',
  },
  visitDurationText: {
    fontSize: 10,
    color: Colors.success,
    fontWeight: '600',
    marginRight: 6,
  },
  ticketFeeText: {
    fontSize: 10,
    color: Colors.warning,
    fontWeight: '600',
    backgroundColor: Colors.background.tertiary,
    paddingHorizontal: 6,
    paddingVertical: 2,
    borderRadius: 6,
    borderWidth: 1,
    borderColor: Colors.warning,
  },
  warningContainer: {
    marginTop: 4,
    backgroundColor: Colors.background.tertiary,
    borderWidth: 1,
    borderColor: Colors.warning,
    borderRadius: 6,
    paddingHorizontal: 8,
    paddingVertical: 4,
  },
  warningText: {
    fontSize: 10,
    color: Colors.warning,
    fontWeight: '600',
    lineHeight: 14,
  },
  workingHoursCompact: {
    backgroundColor: Colors.background.tertiary,
    borderRadius: 12,
    padding: 10,
    borderWidth: 1,
    borderColor: Colors.glassBorder,
    alignItems: 'center',
    minWidth: 90,
  },
  workingHoursCompactLabel: {
    fontSize: 11,
    color: Colors.text.tertiary,
    fontWeight: '600',
    marginBottom: 4,
  },
  workingHoursCompactTime: {
    fontSize: 12,
    fontWeight: '600',
    textAlign: 'center',
    color: Colors.text.primary,
  },
  travelTimeContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginVertical: 8,
    paddingHorizontal: 20,
  },
  travelTimeLine: {
    flex: 1,
    height: 1,
    backgroundColor: Colors.background.quaternary,
  },
  travelTimeContent: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: Colors.background.secondary,
    paddingHorizontal: 18,
    paddingVertical: 14,
    borderRadius: 25,
    marginHorizontal: 10,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 6 },
    shadowOpacity: 0.25,
    shadowRadius: 12,
    elevation: 6,
    borderWidth: 1,
    borderColor: Colors.glassBorder,
  },
  travelTimeIcon: {
    fontSize: 20,
    marginRight: 8,
  },
  travelTimeInfo: {
    flex: 1,
    marginRight: 8,
  },
  travelTimeText: {
    fontSize: 15,
    fontWeight: '600',
    color: Colors.text.primary,
    textTransform: 'capitalize',
  },
  travelFromText: {
    fontSize: 12,
    color: Colors.text.tertiary,
    fontStyle: 'italic',
    marginTop: 2,
  },
  travelDistanceText: {
    fontSize: 13,
    color: Colors.text.secondary,
    marginTop: 3,
  },
  travelTimeBadge: {
    backgroundColor: Colors.primary,
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 12,
    shadowColor: Colors.primary,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.3,
    shadowRadius: 4,
    elevation: 3,
  },
  travelTimeBadgeText: {
    fontSize: 12,
    fontWeight: '700',
    color: Colors.background.primary,
  },
  placeDescription: {
    fontSize: 13,
    color: Colors.text.secondary,
    marginTop: 12,
    lineHeight: 19,
  },
  busynessContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: 4,
  },
  busynessLabel: {
    fontSize: 10,
    color: Colors.text.secondary,
    fontWeight: '500',
  },
  busynessBar: {
    flex: 1,
    height: 6,
    backgroundColor: '#eee',
    borderRadius: 3,
    marginHorizontal: 4,
  },
  busynessFill: {
    height: 6,
    borderRadius: 3,
  },
  busynessText: {
    fontSize: 10,
    color: Colors.text.tertiary,
    fontWeight: '500',
  },
  mapUnavailable: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: Colors.background.tertiary,
  },
  mapUnavailableText: {
    color: Colors.text.secondary,
    fontSize: 15,
    padding: 24,
    textAlign: 'center',
    lineHeight: 22,
  },
  startingPointCard: {
    backgroundColor: Colors.background.secondary,
    borderRadius: 14,
    padding: 16,
    marginBottom: 10,
    borderLeftWidth: 3,
    borderLeftColor: Colors.success,
    borderWidth: 1,
    borderColor: Colors.glassBorder,
  },
  startingPointHeader: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  startingPointIcon: {
    backgroundColor: Colors.success,
    borderRadius: 18,
    width: 36,
    height: 36,
    alignItems: 'center',
    justifyContent: 'center',
    marginRight: 12,
    shadowColor: Colors.success,
    shadowOffset: { width: 0, height: 3 },
    shadowOpacity: 0.25,
    shadowRadius: 6,
    elevation: 4,
  },
  startingPointIconText: {
    fontSize: 16,
  },
  startingPointInfo: {
    flex: 1,
  },
  startingPointTitle: {
    fontSize: 14,
    fontWeight: '700',
    color: Colors.success,
    marginBottom: 3,
    letterSpacing: 0.2,
  },
  startingPointAddress: {
    fontSize: 12,
    color: Colors.text.secondary,
    lineHeight: 17,
  },
  returnPointCard: {
    backgroundColor: Colors.background.secondary,
    borderRadius: 14,
    padding: 16,
    marginTop: 10,
    borderLeftWidth: 3,
    borderLeftColor: Colors.warning,
    borderWidth: 1,
    borderColor: Colors.glassBorder,
  },
  returnPointHeader: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  returnPointIcon: {
    backgroundColor: Colors.warning,
    borderRadius: 18,
    width: 36,
    height: 36,
    alignItems: 'center',
    justifyContent: 'center',
    marginRight: 12,
    shadowColor: Colors.warning,
    shadowOffset: { width: 0, height: 3 },
    shadowOpacity: 0.25,
    shadowRadius: 6,
    elevation: 4,
  },
  returnPointIconText: {
    fontSize: 16,
  },
  returnPointInfo: {
    flex: 1,
  },
  returnPointTitle: {
    fontSize: 14,
    fontWeight: '700',
    color: Colors.warning,
    marginBottom: 3,
    letterSpacing: 0.2,
  },
  returnPointAddress: {
    fontSize: 12,
    color: Colors.text.secondary,
    lineHeight: 17,
  },
  returnPointTime: {
    fontSize: 13,
    color: Colors.warning,
    fontWeight: '600',
    marginTop: 4,
    letterSpacing: 0.2,
  },
  extendedHoursContainer: {
    marginTop: 12,
    backgroundColor: Colors.background.tertiary,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: Colors.glassBorder,
  },
  extendedHoursHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 10,
  },
  extendedHoursTitle: {
    fontSize: 13,
    fontWeight: '600',
    color: Colors.text.secondary,
  },
  expandHoursButton: {
    padding: 6,
  },
  expandHoursText: {
    fontSize: 15,
    color: Colors.primary,
  },
  allHoursContainer: {
    marginTop: 12,
    paddingTop: 12,
    borderTopWidth: 1,
    borderTopColor: Colors.glassBorder,
  },
  allHoursTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: Colors.primary,
    marginBottom: 8,
  },
  dayHoursText: {
    fontSize: 13,
    color: Colors.text.secondary,
    marginBottom: 4,
    fontFamily: Platform.OS === 'ios' ? 'Menlo' : 'monospace',
    lineHeight: 18,
  },
  dayHoursTodayText: {
    fontSize: 14,
    fontWeight: '600',
    color: Colors.success,
    backgroundColor: `${Colors.success}20`,
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderRadius: 6,
  },
  dayHoursClosedText: {
    color: Colors.text.tertiary,
    textDecorationLine: 'line-through',
  },
  // Fixed Multi-Day Navigation styles
  fixedDayNavigation: {
    backgroundColor: Colors.glass,
    borderBottomWidth: 1,
    borderBottomColor: Colors.glassBorder,
    paddingVertical: 6,
    paddingHorizontal: 16,
    backdropFilter: 'blur(20px)',
    position: 'relative',
    zIndex: 999,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.08,
    shadowRadius: 4,
    elevation: 2,
  },
  dayNavigationHeader: {
    marginBottom: 6,
    paddingHorizontal: 8,
  },
  dayNavigationTitle: {
    fontSize: 14,
    fontWeight: '700',
    color: Colors.text.primary,
    marginBottom: 1,
    letterSpacing: 0.2,
  },
  dayNavigationStats: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  dayNavigationSubtitle: {
    fontSize: 12,
    color: Colors.text.secondary,
    fontWeight: '500',
    letterSpacing: 0.1,
  },
  dayNavigationTimes: {
    fontSize: 12,
    color: Colors.text.tertiary,
    fontWeight: '400',
    letterSpacing: 0.1,
  },
  dayTabsContent: {
    paddingHorizontal: 8,
  },
  dayTab: {
    backgroundColor: Colors.background.tertiary,
    borderRadius: 12,
    padding: 8,
    marginRight: 8,
    minWidth: 80,
    borderWidth: 1.5,
    borderColor: Colors.glassBorder,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.08,
    shadowRadius: 2,
    elevation: 1,
  },
  dayTabActive: {
    backgroundColor: Colors.primary,
    borderColor: Colors.primary,
    shadowColor: Colors.primary,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 3,
    transform: [{ scale: 1.01 }],
  },
  dayTabContent: {
    alignItems: 'center',
    justifyContent: 'center',
  },
  dayTabHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 4,
    marginBottom: 1,
  },
  dayTabText: {
    fontSize: 12,
    fontWeight: '700',
    color: Colors.text.primary,
    letterSpacing: 0.1,
    marginBottom: 1,
  },
  dayTabTextActive: {
    color: Colors.background.primary,
    fontWeight: '800',
    textShadowColor: 'rgba(0, 0, 0, 0.2)',
    textShadowOffset: { width: 0, height: 1 },
    textShadowRadius: 1,
  },
  dayTabDate: {
    fontSize: 10,
    color: Colors.text.secondary,
    fontWeight: '600',
    marginBottom: 2,
    letterSpacing: 0.1,
  },
  dayTabDateActive: {
    color: 'rgba(255, 255, 255, 0.95)',
    fontWeight: '700',
  },
  dayTabStats: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 2,
  },
  dayTabInfo: {
    fontSize: 9,
    color: Colors.text.tertiary,
    fontWeight: '500',
  },
  dayTabInfoActive: {
    color: 'rgba(255, 255, 255, 0.9)',
    fontWeight: '600',
  },
  activeIndicator: {
    width: 4,
    height: 4,
    borderRadius: 2,
    backgroundColor: Colors.background.primary,
    shadowColor: Colors.background.primary,
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.4,
    shadowRadius: 1,
  },
  // Collapsible Summary Styles
  summaryContainer: {
    backgroundColor: Colors.background.secondary,
    marginHorizontal: 16,
    marginVertical: 8,
    borderRadius: 16,
    borderWidth: 1,
    borderColor: Colors.glassBorder,
    overflow: 'hidden',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 3,
  },
  summaryHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 16,
    paddingVertical: 12,
    backgroundColor: Colors.background.tertiary,
  },
  summaryHeaderContent: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
  },
  summaryTitle: {
    fontSize: 13,
    fontWeight: '700',
    color: Colors.text.primary,
    letterSpacing: 0.2,
  },
  summaryQuickStats: {
    backgroundColor: Colors.primary,
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
  },
  summaryQuickText: {
    fontSize: 10,
    fontWeight: '600',
    color: Colors.background.primary,
    letterSpacing: 0.1,
  },
  summaryChevron: {
    marginLeft: 12,
  },
  summaryChevronText: {
    fontSize: 12,
    color: Colors.text.secondary,
    fontWeight: '600',
  },
  summaryContent: {
    backgroundColor: Colors.background.secondary,
    overflow: 'hidden',
  },
  summaryGrid: {
    flexDirection: 'row',
    paddingHorizontal: 16,
    paddingVertical: 16,
    gap: 16,
  },
  summaryStat: {
    flex: 1,
    alignItems: 'center',
  },
  summaryStatContent: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 4,
  },
  summaryStatIcon: {
    fontSize: 18,
    marginBottom: 4,
  },
  summaryStatValue: {
    fontSize: 16,
    fontWeight: '800',
    color: Colors.primary,
    marginBottom: 2,
  },
  summaryStatLabel: {
    fontSize: 10,
    color: Colors.text.secondary,
    fontWeight: '600',
    textTransform: 'uppercase',
    letterSpacing: 0.3,
    textAlign: 'center',
  },
  dailyBreakdown: {
    paddingHorizontal: 16,
    paddingBottom: 16,
    borderTopWidth: 1,
    borderTopColor: Colors.glassBorder,
  },
  dailyBreakdownTitle: {
    fontSize: 14,
    fontWeight: '700',
    color: Colors.text.primary,
    marginTop: 12,
    marginBottom: 8,
    letterSpacing: 0.2,
  },
  dailyBreakdownItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 6,
  },
  dailyBreakdownDay: {
    fontSize: 13,
    fontWeight: '600',
    color: Colors.text.primary,
  },
  dailyBreakdownInfo: {
    fontSize: 12,
    color: Colors.text.secondary,
    fontWeight: '500',
  },
  totalDurationRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderTopWidth: 1,
    borderTopColor: Colors.glassBorder,
    backgroundColor: Colors.background.tertiary,
  },
  totalDurationLabel: {
    fontSize: 14,
    fontWeight: '700',
    color: Colors.text.primary,
    letterSpacing: 0.2,
  },
  totalDurationValue: {
    fontSize: 18,
    fontWeight: '800',
    color: Colors.primary,
    letterSpacing: 0.3,
  },
  travelBreakdownContainer: {
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderTopWidth: 1,
    borderTopColor: Colors.glassBorder,
    backgroundColor: Colors.background.tertiary,
  },
  travelBreakdownTitle: {
    fontSize: 11,
    fontWeight: '600',
    color: Colors.text.secondary,
    marginBottom: 6,
    textTransform: 'uppercase',
    letterSpacing: 0.3,
  },
  travelBreakdownRow: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    gap: 16,
  },
  travelModeItem: {
    flex: 1,
    alignItems: 'center',
    backgroundColor: Colors.background.secondary,
    borderRadius: 10,
    padding: 8,
    borderWidth: 1,
    borderColor: Colors.glassBorder,
    marginHorizontal: 4,
  },
  travelModeIcon: {
    fontSize: 16,
    marginBottom: 3,
  },
  travelModeLabel: {
    fontSize: 9,
    fontWeight: '600',
    color: Colors.text.secondary,
    marginBottom: 3,
    textTransform: 'uppercase',
    letterSpacing: 0.2,
  },
  travelModeTime: {
    fontSize: 11,
    fontWeight: '700',
    color: Colors.text.primary,
  },
  missedPlacesContainer: {
    marginTop: 20,
    padding: 16,
    backgroundColor: Colors.background.tertiary,
    borderRadius: 16,
    borderLeftWidth: 4,
    borderLeftColor: Colors.warning,
  },
  missedPlacesTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: Colors.warning,
    marginBottom: 12,
    letterSpacing: 0.3,
  },
  missedPlaceItem: {
    backgroundColor: Colors.background.secondary,
    borderRadius: 12,
    padding: 16,
    marginBottom: 12,
    borderWidth: 1,
    borderColor: Colors.glassBorder,
  },
  missedPlaceName: {
    fontSize: 15,
    fontWeight: '600',
    color: Colors.text.primary,
    marginBottom: 6,
  },
  missedPlaceReason: {
    fontSize: 13,
    color: Colors.text.secondary,
    marginBottom: 6,
    fontStyle: 'italic',
    lineHeight: 18,
  },
  missedPlaceReviews: {
    fontSize: 12,
    color: Colors.text.tertiary,
    fontWeight: '500',
  },
  multiDaySummary: {
    backgroundColor: Colors.background.secondary,
    margin: 24,
    borderRadius: 20,
    padding: 24,
    borderWidth: 1,
    borderColor: Colors.glassBorder,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 8 },
    shadowOpacity: 0.3,
    shadowRadius: 16,
    elevation: 8,
  },
  multiDaySummaryTitle: {
    fontSize: 20,
    fontWeight: '700',
    color: Colors.text.primary,
    marginBottom: 16,
    textAlign: 'center',
    letterSpacing: 0.5,
  },
  multiDayStatsRow: {
    flexDirection: 'row',
    justifyContent: 'space-around',
  },
  multiDayStat: {
    alignItems: 'center',
  },
  multiDayStatValue: {
    fontSize: 22,
    fontWeight: '700',
    color: Colors.primary,
  },
  multiDayStatLabel: {
    fontSize: 13,
    color: Colors.text.secondary,
    marginTop: 6,
  },
  // Dining Stop Styles
  diningStopButton: {
    marginVertical: 8,
    marginHorizontal: 16,
  },
  diningStopCard: {
    backgroundColor: '#2a2a2a',
    borderRadius: 16,
    padding: 16,
    marginVertical: 8,
    marginHorizontal: 16,
    borderWidth: 2,
    borderColor: '#4ECDC4',
    borderStyle: 'solid',
    shadowColor: '#4ECDC4',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.3,
    shadowRadius: 8,
    elevation: 8,
  },
  diningStopHeader: {
    flexDirection: 'row',
    alignItems: 'flex-start',
    marginBottom: 12,
    minHeight: 100,
  },
  diningStopEmoji: {
    fontSize: 28,
    marginRight: 12,
  },
  diningStopInfo: {
    flex: 1,
    marginRight: 12,
  },
  diningStopName: {
    fontSize: 15,
    fontWeight: '700',
    color: Colors.text.primary,
    marginBottom: 3,
  },
  diningStopType: {
    fontSize: 11,
    color: Colors.primary,
    fontWeight: '600',
    marginBottom: 3,
  },
  diningStopAddress: {
    fontSize: 11,
    color: Colors.text.secondary,
    lineHeight: 16,
  },
  diningStopStats: {
    alignItems: 'flex-end',
  },

  // Horizontal Layout Design
  diningContentRow: {
    flexDirection: 'row',
    alignItems: 'flex-start',
    gap: 12,
    minHeight: 80,
  },

  diningMainContent: {
    flex: 1,
    paddingRight: 8,
    minHeight: 120, // Added minimum height to ensure button is visible
  },

  diningTopRow: {
    marginBottom: 12,
  },

  diningMealTypeChip: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.8)',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 16,
    alignSelf: 'flex-start',
  },

  diningMealTypeIcon: {
    fontSize: 14,
    marginRight: 6,
  },

  diningMealTypeText: {
    fontSize: 11,
    fontWeight: '700',
    color: '#FFFFFF',
    letterSpacing: 0.5,
  },

  diningRatingRow: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
    marginBottom: 12,
  },

  diningImageContainer: {
    alignItems: 'center',
    justifyContent: 'flex-start',
    width: 80,
    height: 80,
  },

  // Compact Circular Travel Design
  compactTravelRow: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 8,
    paddingHorizontal: 16,
    gap: 16,
  },

  circularTravelIndicator: {
    width: 60,
    height: 60,
    borderRadius: 30,
    backgroundColor: 'rgba(0, 217, 255, 0.1)',
    borderWidth: 2,
    borderColor: 'rgba(0, 217, 255, 0.3)',
    alignItems: 'center',
    justifyContent: 'center',
    position: 'relative',
  },

  circularTravelIcon: {
    fontSize: 22,
    marginBottom: 2,
  },

  circularTravelTime: {
    fontSize: 10,
    fontWeight: '700',
    color: '#00D9FF',
    position: 'absolute',
    bottom: 4,
  },

  circularAddFoodButton: {
    width: 48,
    height: 48,
    borderRadius: 24,
    backgroundColor: 'rgba(48, 209, 88, 0.15)',
    borderWidth: 2,
    borderColor: 'rgba(48, 209, 88, 0.4)',
    borderStyle: 'dashed',
    alignItems: 'center',
    justifyContent: 'center',
  },

  circularAddFoodIcon: {
    fontSize: 24,
    fontWeight: '300',
    color: '#30D158',
  },

  activeFoodButton: {
    backgroundColor: 'rgba(48, 209, 88, 0.3)',
    borderColor: '#30D158',
    borderStyle: 'solid',
  },

  // Remove Dining Stop Button
  removeDiningButton: {
    position: 'absolute',
    top: 8,
    right: 8,
    width: 28,
    height: 28,
    borderRadius: 14,
    backgroundColor: 'rgba(255, 59, 48, 0.9)',
    alignItems: 'center',
    justifyContent: 'center',
    zIndex: 10,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.3,
    shadowRadius: 4,
    elevation: 5,
  },

  removeDiningIcon: {
    fontSize: 18,
    fontWeight: '400',
    color: '#FFFFFF',
    lineHeight: 18,
  },

  // Dining Stop Map Markers
  diningMarkerContainer: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: '#FF6B35',
    borderWidth: 3,
    borderColor: '#FFFFFF',
    alignItems: 'center',
    justifyContent: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.3,
    shadowRadius: 4,
    elevation: 5,
  },

  diningMarkerText: {
    fontSize: 20,
    textAlign: 'center',
  },

  // Change Place Button
  changePlaceButton: {
    position: 'absolute',
    top: 8,
    right: 8,
    width: 32,
    height: 32,
    borderRadius: 16,
    backgroundColor: 'rgba(52, 152, 219, 0.9)',
    alignItems: 'center',
    justifyContent: 'center',
    zIndex: 10,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.3,
    shadowRadius: 4,
    elevation: 5,
  },

  changePlaceIcon: {
    fontSize: 16,
    fontWeight: '600',
    color: '#FFFFFF',
  },

  diningRatingValue: {
    fontSize: 14,
    fontWeight: '700',
    color: '#FFD700',
    marginBottom: 4,
  },

  diningPriceValue: {
    fontSize: 12,
    fontWeight: '600',
    color: '#30D158',
  },

  diningMetricsRow: {
    flexDirection: 'row',
    gap: 12,
  },

  diningMetricsColumn: {
    flexDirection: 'column',
    gap: 8,
  },

  diningMetricsRowFixed: {
    flexDirection: 'row',
    gap: 6,
    flexWrap: 'nowrap',
    alignItems: 'center',
  },

  diningTimeChip: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 217, 255, 0.1)',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: 'rgba(0, 217, 255, 0.2)',
    flex: 1,
    maxWidth: '65%',
  },

  diningTimeIcon: {
    fontSize: 12,
    marginRight: 6,
  },

  diningTimeText: {
    fontSize: 11,
    fontWeight: '600',
    color: '#00D9FF',
  },

  diningDurationChip: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(48, 209, 88, 0.1)',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: 'rgba(48, 209, 88, 0.2)',
    flexShrink: 0,
    minWidth: 60,
  },

  diningDurationIcon: {
    fontSize: 12,
    marginRight: 6,
  },

  diningDurationText: {
    fontSize: 11,
    fontWeight: '700',
    color: '#30D158',
  },

  // Reserve Button Styles
  reserveButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: Colors.primary, // Changed to app's cyan blue theme
    borderRadius: 12,
    paddingVertical: 12, // Increased padding
    paddingHorizontal: 20, // Increased padding
    marginTop: 16, // Increased margin
    marginBottom: 8, // Added bottom margin
    shadowColor: Colors.primary,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.5,
    shadowRadius: 8,
    elevation: 8,
    borderWidth: 2, // Added border
    borderColor: '#FFFFFF',
    zIndex: 999, // Ensure button is on top
    position: 'relative', // Required for zIndex to work
  },

  reserveButtonIcon: {
    fontSize: 16,
    marginRight: 8,
  },

  reserveButtonText: {
    fontSize: 13,
    fontWeight: '700',
    color: '#FFFFFF',
    letterSpacing: 0.5,
  },

  // Reserve Button Inside - Compact inside the card
  reserveButtonInside: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: Colors.primary,
    borderRadius: 8,
    paddingVertical: 6,
    paddingHorizontal: 12,
    marginTop: 8,
    marginRight: 8,
    shadowColor: Colors.primary,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.3,
    shadowRadius: 4,
    elevation: 4,
    borderWidth: 1,
    borderColor: '#FFFFFF',
    alignSelf: 'flex-start',
  },
  diningStopRating: {
    fontSize: 12,
    fontWeight: '600',
    color: Colors.text.primary,
    marginBottom: 3,
  },
  diningStopPrice: {
    fontSize: 11,
  },
  diningStopDetails: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    backgroundColor: Colors.background.primary,
    borderRadius: 12,
    padding: 12,
    borderWidth: 1,
    borderColor: Colors.glassBorder,
  },
  diningStopDetour: {
    fontSize: 12,
    color: Colors.primary,
    fontWeight: '600',
  },
  diningStopTime: {
    fontSize: 12,
    color: Colors.primary,
    fontWeight: '600',
  },
  diningStopDuration: {
    fontSize: 12,
    color: Colors.primary,
    fontWeight: '600',
  },
  editIndicator: {
    alignSelf: 'center',
    marginTop: 8,
    paddingVertical: 4,
    paddingHorizontal: 8,
    backgroundColor: '#333333',
    borderRadius: 12,
  },
  editDiningButton: {
    alignSelf: 'center',
    marginTop: 8,
    paddingVertical: 4,
    paddingHorizontal: 8,
    backgroundColor: '#333333',
    borderRadius: 12,
  },
  editIndicatorText: {
    fontSize: 10,
    color: '#888888',
    fontStyle: 'italic',
  },
  // Time breakdown styles for dining stops
  timeBreakdownRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 8,
  },
  timeBreakdownItem: {
    fontSize: 10,
    color: '#4ECDC4',
    fontWeight: '500',
    textAlign: 'center',
    flex: 1,
  },
  totalImpactRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingTop: 8,
    borderTopWidth: 1,
    borderTopColor: '#333333',
    marginTop: 4,
  },
  totalImpactLabel: {
    fontSize: 11,
    color: '#ffffff',
    fontWeight: '600',
  },
  totalImpactValue: {
    fontSize: 11,
    color: '#4ECDC4',
    fontWeight: 'bold',
  },
  extraTravelNote: {
    fontSize: 10,
    color: Colors.text.tertiary,
    fontStyle: 'italic',
    textAlign: 'center',
    marginTop: 6,
  },
  // Meal types breakdown styles
  mealTypesContainer: {
    marginTop: 12,
    padding: 12,
    backgroundColor: Colors.background.tertiary,
    borderRadius: 12,
    borderLeftWidth: 3,
    borderLeftColor: Colors.primary,
  },
  mealTypesTitle: {
    fontSize: 13,
    fontWeight: '600',
    color: Colors.primary,
    marginBottom: 8,
    letterSpacing: 0.2,
  },
  mealTypesGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 6,
  },
  mealTypeItem: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: Colors.background.secondary,
    borderRadius: 8,
    padding: 8,
    borderWidth: 1,
    borderColor: Colors.glassBorder,
    marginBottom: 4,
  },
  mealTypeEmoji: {
    fontSize: 14,
    marginRight: 4,
  },
  mealTypeText: {
    fontSize: 11,
    color: Colors.text.primary,
    fontWeight: '600',
  },
  // Add another stop button styles
  addAnotherStopButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#333333',
    borderRadius: 12,
    padding: 12,
    marginVertical: 8,
    marginHorizontal: 16,
    borderWidth: 2,
    borderColor: '#4ECDC4',
    borderStyle: 'dashed',
  },
  addAnotherStopIcon: {
    fontSize: 18,
    color: '#4ECDC4',
    fontWeight: 'bold',
    marginRight: 8,
  },
  addAnotherStopText: {
    fontSize: 14,
    color: '#4ECDC4',
    fontWeight: '600',
  },
  // Enhanced Travel Breakdown Styles - Second Definition (Remove)
  // Note: This is a duplicate, keeping the first definition above
  travelSegment: {
    alignItems: 'center',
    flex: 1,
  },
  travelIcon: {
    fontSize: 20,
    marginBottom: 4,
  },
  travelLabel: {
    fontSize: 11,
    color: Colors.text.tertiary,
    textAlign: 'center',
    marginBottom: 3,
  },
  travelTime: {
    fontSize: 13,
    color: Colors.primary,
    fontWeight: '600',
    textAlign: 'center',
  },
  summaryInfoRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 8,
  },
  squareCardInSummary: {
    flex: 1,
    marginHorizontal: 4,
    padding: 8,
    borderRadius: 8,
    backgroundColor: Colors.background.tertiary,
    borderWidth: 1,
    borderColor: Colors.glassBorder,
    alignItems: 'center',
    justifyContent: 'center',
  },
  // Main Flow Travel Segment Styles
  travelSegmentBlock: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: Colors.background.tertiary,
    marginVertical: 6,
    marginHorizontal: 24,
    paddingVertical: 16,
    paddingHorizontal: 20,
    borderRadius: 16,
    borderLeftWidth: 4,
    borderLeftColor: Colors.primary,
    borderWidth: 1,
    borderColor: Colors.glassBorder,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.2,
    shadowRadius: 8,
    elevation: 4,
  },
  travelSegmentIcon: {
    marginRight: 12,
  },
  travelSegmentIconText: {
    fontSize: 24,
  },
  travelSegmentInfo: {
    flex: 1,
  },
  travelSegmentTime: {
    fontSize: 17,
    fontWeight: '700',
    color: Colors.primary,
    marginBottom: 4,
  },
  travelSegmentLabel: {
    fontSize: 13,
    color: Colors.text.secondary,
    fontWeight: '500',
  },
  
  // Square Info Cards Grid
  infoCardsGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginHorizontal: 20,
    marginVertical: 10,
    gap: 8,
    justifyContent: 'space-between',
  },

  // Grid variations based on number of items
  infoCardsGridTwoItems: {
    justifyContent: 'center',
    gap: 16,
  },

  infoCardsGridOneItem: {
    justifyContent: 'center',
  },

  squareCard: {
    backgroundColor: Colors.background.secondary,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: Colors.glassBorder,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 3 },
    shadowOpacity: 0.12,
    shadowRadius: 6,
    elevation: 3,
    alignItems: 'center',
    justifyContent: 'center',
    padding: 12,
    minHeight: 70,
    width: (width - 76) / 3, // Default: Three cards per row
  },

  // Square card size variations
  squareCardThreePerRow: {
    width: (width - 76) / 3, // Three cards per row with margins and gaps
  },

  squareCardTwoPerRow: {
    width: (width - 72) / 2, // Two cards per row with margins and gap
  },

  squareCardOnePerRow: {
    width: (width - 80) / 2, // Centered single card (but not too wide)
  },

  squareCardIcon: {
    fontSize: 18,
    marginBottom: 4,
  },

  squareCardTitle: {
    fontSize: 11,
    fontWeight: '700',
    color: Colors.text.primary,
    textAlign: 'center',
    letterSpacing: 0.1,
  },

  squareCardSubtitle: {
    fontSize: 9,
    fontWeight: '500',
    color: Colors.text.secondary,
    textAlign: 'center',
    marginTop: 1,
  },

  squareCardBadge: {
    fontSize: 10,
    fontWeight: '700',
    color: Colors.background.primary,
    backgroundColor: Colors.primary,
    paddingHorizontal: 6,
    paddingVertical: 2,
    borderRadius: 8,
    minWidth: 20,
    textAlign: 'center',
    marginTop: 3,
  },

  // Optimization Notes Panel Styles (Updated)
  optimizationContainer: {
    backgroundColor: 'transparent',
    borderRadius: 0,
    marginHorizontal: 0,
    marginVertical: 0,
    borderWidth: 0,
    overflow: 'hidden',
  },
  
  optimizationHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 10,
    backgroundColor: 'transparent',
  },
  
  optimizationHeaderContent: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
  },
  
  optimizationTitle: {
    fontSize: 12,
    fontWeight: '500',
    color: Colors.text.secondary,
    letterSpacing: 0.1,
  },
  
  optimizationCount: {
    fontSize: 10,
    fontWeight: '600',
    color: Colors.text.tertiary,
    marginLeft: 4,
  },
  
  expandIcon: {
    fontSize: 12,
    color: Colors.text.tertiary,
    fontWeight: 'bold',
  },
  
  optimizationContent: {
    overflow: 'hidden',
  },
  
  optimizationScrollView: {
    paddingHorizontal: 10,
    paddingVertical: 4,
  },
  
  optimizationNote: {
    fontSize: 11,
    color: Colors.text.secondary,
    lineHeight: 16,
    marginBottom: 4,
    paddingLeft: 0,
  },
  
  // Dining Schedule Information Styles
  diningScheduleInfo: {
    paddingVertical: 12,
    paddingHorizontal: 0,
    marginTop: 12,
  },

  diningScheduleRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
  },

  diningScheduleLeft: {
    flex: 1,
    marginRight: 12,
    minWidth: 300,
  },

  diningScheduleText: {
    fontSize: 14,
    fontWeight: '700',
    color: '#FFFFFF',
    marginBottom: 6,
  },

  diningVisitInfoRow: {
    flexDirection: 'row',
    alignItems: 'center',
    flexWrap: 'wrap',
    marginTop: 6,
  },

  diningVisitDurationText: {
    fontSize: 13,
    color: '#30D158',
    fontWeight: '700',
    marginRight: 12,
  },

  diningExtraTravelText: {
    fontSize: 12,
    color: '#FF9F0A',
    fontWeight: '700',
    backgroundColor: 'rgba(255, 159, 10, 0.25)',
    paddingHorizontal: 8,
    paddingVertical: 3,
    borderRadius: 8,
  },

  // Legacy Simplified Dining Container Styles (kept for compatibility)
  simplifiedDiningContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 12,
    paddingHorizontal: 16,
  },
  
  diningIcon: {
    fontSize: 20,
    marginRight: 8,
  },
  
  diningLabel: {
    fontSize: 14,
    fontWeight: '600',
    color: Colors.text.primary,
    marginRight: 12,
  },
  
  diningTime: {
    fontSize: 14,
    fontWeight: '500',
    color: Colors.text.secondary,
  },
  
  // Visit Duration Editing Styles
  visitDurationButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(76, 205, 196, 0.1)',
    borderRadius: 8,
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderWidth: 1,
    borderColor: 'rgba(76, 205, 196, 0.3)',
  },
  
  editIcon: {
    fontSize: 12,
    marginLeft: 6,
    color: Colors.accent,
  },
  
  // Visit Duration Modal Styles
  durationModalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.8)',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  
  durationModalContent: {
    backgroundColor: Colors.background.card,
    borderRadius: 20,
    padding: 24,
    width: '100%',
    maxWidth: 400,
    borderWidth: 1,
    borderColor: Colors.glassBorder,
  },
  
  durationModalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 16,
  },
  
  durationModalTitle: {
    fontSize: 20,
    fontWeight: '700',
    color: Colors.text.primary,
    letterSpacing: 0.3,
  },
  
  durationModalClose: {
    padding: 8,
    borderRadius: 8,
    backgroundColor: Colors.background.tertiary,
  },
  
  durationModalCloseText: {
    fontSize: 16,
    color: Colors.text.secondary,
    fontWeight: 'bold',
  },
  
  durationModalPlaceName: {
    fontSize: 16,
    fontWeight: '600',
    color: Colors.accent,
    marginBottom: 20,
    textAlign: 'center',
  },
  
  durationInputContainer: {
    marginBottom: 24,
  },
  
  durationInputLabel: {
    fontSize: 14,
    fontWeight: '600',
    color: Colors.text.secondary,
    marginBottom: 8,
    textTransform: 'uppercase',
    letterSpacing: 0.5,
  },
  
  durationInput: {
    backgroundColor: Colors.background.tertiary,
    borderRadius: 12,
    padding: 16,
    fontSize: 16,
    color: Colors.text.primary,
    borderWidth: 1,
    borderColor: Colors.glassBorder,
    textAlign: 'center',
    fontWeight: '600',
  },
  
  durationInputHint: {
    fontSize: 12,
    color: Colors.text.tertiary,
    textAlign: 'center',
    marginTop: 8,
  },
  
  durationModalButtons: {
    flexDirection: 'row',
    gap: 12,
  },
  
  durationModalButton: {
    flex: 1,
    borderRadius: 12,
    padding: 16,
    alignItems: 'center',
    justifyContent: 'center',
  },
  
  durationModalCancel: {
    backgroundColor: Colors.background.tertiary,
    borderWidth: 1,
    borderColor: Colors.glassBorder,
  },
  
  durationModalSave: {
    backgroundColor: Colors.primary,
  },
  
  durationModalCancelText: {
    fontSize: 16,
    fontWeight: '600',
    color: Colors.text.secondary,
  },
  
  durationModalSaveText: {
    fontSize: 16,
    fontWeight: '700',
    color: Colors.background.primary,
  },
  
  // Detail Modal Styles
  detailModalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.8)',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  
  detailModalContent: {
    backgroundColor: Colors.background.secondary,
    borderRadius: 20,
    width: '100%',
    maxWidth: 400,
    maxHeight: '80%',
    borderWidth: 1,
    borderColor: Colors.glassBorder,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 8 },
    shadowOpacity: 0.3,
    shadowRadius: 16,
    elevation: 12,
  },
  
  detailModalHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 20,
    borderBottomWidth: 1,
    borderBottomColor: Colors.glassBorder,
  },
  
  detailModalIcon: {
    fontSize: 24,
    marginRight: 12,
  },
  
  detailModalTitle: {
    fontSize: 18,
    fontWeight: '700',
    color: Colors.text.primary,
    flex: 1,
    letterSpacing: 0.3,
  },
  
  detailModalClose: {
    padding: 8,
    borderRadius: 8,
    backgroundColor: Colors.background.tertiary,
  },
  
  detailModalCloseText: {
    fontSize: 16,
    color: Colors.text.secondary,
    fontWeight: 'bold',
  },
  
  detailModalScroll: {
    padding: 20,
    maxHeight: 300,
  },
  
  detailModalItem: {
    flexDirection: 'row',
    marginBottom: 12,
    alignItems: 'flex-start',
  },
  
  detailModalBullet: {
    fontSize: 16,
    color: Colors.primary,
    marginRight: 8,
    marginTop: 2,
  },
  
  detailModalText: {
    fontSize: 14,
    color: Colors.text.secondary,
    lineHeight: 20,
    flex: 1,
  },
  
  detailModalFooter: {
    fontSize: 12,
    color: Colors.text.tertiary,
    fontStyle: 'italic',
    textAlign: 'center',
    padding: 16,
    borderTopWidth: 1,
    borderTopColor: Colors.glassBorder,
  },
  
  // Popular Places Modal Styles
  popularPlaceItem: {
    backgroundColor: Colors.background.tertiary,
    borderRadius: 12,
    padding: 16,
    marginBottom: 12,
    borderWidth: 1,
    borderColor: Colors.glassBorder,
  },
  
  popularPlaceName: {
    fontSize: 16,
    fontWeight: '700',
    color: Colors.text.primary,
    marginBottom: 6,
  },
  
  popularPlaceRating: {
    fontSize: 13,
    color: Colors.warning,
    marginBottom: 4,
  },
  
  popularPlaceReason: {
    fontSize: 12,
    color: Colors.text.secondary,
    fontStyle: 'italic',
  },
  
  // Dining Modal Styles
  diningTypeItem: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: Colors.background.tertiary,
    borderRadius: 12,
    padding: 16,
    marginBottom: 8,
    borderWidth: 1,
    borderColor: Colors.glassBorder,
  },
  
  diningTypeEmoji: {
    fontSize: 20,
    marginRight: 12,
  },
  
  diningTypeText: {
    fontSize: 15,
    fontWeight: '600',
    color: Colors.text.primary,
    flex: 1,
  },
  
  diningTypeCount: {
    fontSize: 14,
    fontWeight: '700',
    color: Colors.primary,
    backgroundColor: 'rgba(0, 217, 255, 0.15)',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 8,
    minWidth: 30,
    textAlign: 'center',
  },
  
  diningStatsContainer: {
    marginTop: 16,
    padding: 16,
    backgroundColor: Colors.background.tertiary,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: Colors.glassBorder,
  },
  
  diningStatsTitle: {
    fontSize: 14,
    fontWeight: '700',
    color: Colors.primary,
    marginBottom: 8,
  },
  
  diningStatsText: {
    fontSize: 13,
    color: Colors.text.secondary,
    marginBottom: 4,
  },

  // Change Place Modal Styles
  currentPlaceSection: {
    marginBottom: 20,
    padding: 16,
    backgroundColor: 'rgba(255, 59, 48, 0.1)',
    borderRadius: 12,
    borderWidth: 1,
    borderColor: 'rgba(255, 59, 48, 0.3)',
  },

  currentPlaceTitle: {
    fontSize: 14,
    fontWeight: '700',
    color: '#FF3B30',
    marginBottom: 8,
  },

  currentPlaceCard: {
    padding: 12,
    backgroundColor: 'rgba(0, 0, 0, 0.3)',
    borderRadius: 8,
  },

  currentPlaceName: {
    fontSize: 16,
    fontWeight: '700',
    color: Colors.text.primary,
    marginBottom: 4,
  },

  currentPlaceAddress: {
    fontSize: 13,
    color: Colors.text.secondary,
    marginBottom: 4,
  },

  currentPlaceRating: {
    fontSize: 14,
    fontWeight: '600',
    color: '#FFD700',
  },

  alternativesTitle: {
    fontSize: 16,
    fontWeight: '700',
    color: Colors.text.primary,
    marginBottom: 16,
  },

  loadingContainer: {
    padding: 40,
    alignItems: 'center',
  },

  loadingText: {
    fontSize: 14,
    color: Colors.text.secondary,
    marginTop: 12,
  },

  alternativeCard: {
    backgroundColor: Colors.background.secondary,
    borderRadius: 12,
    padding: 16,
    marginBottom: 12,
    borderWidth: 1,
    borderColor: Colors.background.quaternary,
  },

  alternativeHeader: {
    flexDirection: 'row',
    alignItems: 'flex-start',
    marginBottom: 12,
  },

  alternativeInfo: {
    flex: 1,
    marginRight: 12,
  },

  alternativeName: {
    fontSize: 15,
    fontWeight: '700',
    color: Colors.text.primary,
    marginBottom: 4,
  },

  alternativeAddress: {
    fontSize: 12,
    color: Colors.text.secondary,
    marginBottom: 6,
  },

  alternativeDetails: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },

  alternativeRating: {
    fontSize: 13,
    fontWeight: '600',
    color: '#FFD700',
  },

  alternativeReviews: {
    fontSize: 12,
    color: Colors.text.secondary,
  },

  alternativePrice: {
    fontSize: 12,
    fontWeight: '600',
    color: '#30D158',
  },

  selectButton: {
    backgroundColor: Colors.primary,
    borderRadius: 8,
    paddingVertical: 10,
    paddingHorizontal: 16,
    alignItems: 'center',
  },

  selectButtonText: {
    fontSize: 14,
    fontWeight: '700',
    color: '#000000',
  },

  // Closed place styles
  alternativeCardClosed: {
    opacity: 0.6,
    backgroundColor: Colors.background.tertiary,
    borderColor: '#8E8E93',
  },

  alternativeNameRow: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    marginBottom: 4,
  },

  alternativeNameClosed: {
    color: '#8E8E93',
  },

  alternativeAddressClosed: {
    color: '#636366',
  },

  alternativeRatingClosed: {
    color: '#8E8E93',
  },

  alternativeReviewsClosed: {
    color: '#636366',
  },

  alternativePriceClosed: {
    color: '#8E8E93',
  },

  alternativeImageContainer: {
    // Default styles for image container
  },

  alternativeImageClosed: {
    opacity: 0.5,
  },

  closedBadge: {
    backgroundColor: '#FF3B30',
    borderRadius: 4,
    paddingHorizontal: 6,
    paddingVertical: 2,
    marginLeft: 8,
  },

  closedBadgeText: {
    fontSize: 10,
    fontWeight: '700',
    color: '#FFFFFF',
  },

  closedReason: {
    fontSize: 11,
    color: '#FF9F0A',
    fontStyle: 'italic',
    marginBottom: 4,
  },

  selectButtonClosed: {
    backgroundColor: '#48484A',
    borderWidth: 1,
    borderColor: '#8E8E93',
  },

  selectButtonTextClosed: {
    color: '#8E8E93',
  },

  // Category section styles
  categorySection: {
    marginBottom: 24,
  },

  categoryTitle: {
    fontSize: 14,
    fontWeight: '700',
    color: Colors.text.primary,
    marginBottom: 6,
    paddingBottom: 8,
    borderBottomWidth: 1,
    borderBottomColor: Colors.background.quaternary,
  },

  // Floating Action Buttons Styles
  floatingActionContainer: {
    position: 'absolute',
    bottom: 20,
    left: 20,
    right: 20,
    flexDirection: 'row',
    gap: 12,
    zIndex: 1000,
  },

  floatingPrintButton: {
    width: 56,
    height: 56,
    backgroundColor: Colors.background.tertiary,
    borderRadius: 28,
    alignItems: 'center',
    justifyContent: 'center',
    borderWidth: 1,
    borderColor: Colors.glassBorder,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 8,
    elevation: 8,
  },

  floatingPrintButtonText: {
    fontSize: 20,
    fontWeight: '600',
    color: Colors.text.primary,
  },

  floatingCheckoutButton: {
    flex: 1,
    height: 56,
    backgroundColor: '#4ECDC4',
    borderRadius: 28,
    alignItems: 'center',
    justifyContent: 'center',
    shadowColor: '#4ECDC4',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.6,
    shadowRadius: 12,
    elevation: 12,
    borderWidth: 2,
    borderColor: '#ffffff',
  },

  floatingCheckoutButtonText: {
    fontSize: 16,
    fontWeight: '700',
    color: '#ffffff',
    textAlign: 'center',
  },

  disabledFloatingCheckoutButton: {
    backgroundColor: '#666666',
    opacity: 0.8,
    shadowOpacity: 0.2,
    elevation: 4,
    borderColor: '#999999',
  },

  // Legacy styles for backward compatibility
  bottomActionButtons: {
    flexDirection: 'row',
    paddingHorizontal: 20,
    paddingVertical: 16,
    gap: 12,
    marginTop: 10,
  },

  printButton: {
    flex: 1,
    backgroundColor: Colors.background.tertiary,
    borderRadius: 8,
    paddingVertical: 6,
    paddingHorizontal: 10,
    alignItems: 'center',
    justifyContent: 'center',
    borderWidth: 1,
    borderColor: Colors.glassBorder,
  },

  printButtonText: {
    fontSize: 16,
    fontWeight: '600',
    color: Colors.text.primary,
  },

  checkoutButton: {
    flex: 1,
    backgroundColor: Colors.primary,
    borderRadius: 8,
    paddingVertical: 6,
    paddingHorizontal: 10,
    alignItems: 'center',
    justifyContent: 'center',
    shadowColor: Colors.primary,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 8,
    elevation: 6,
  },

  checkoutButtonText: {
    fontSize: 16,
    fontWeight: '700',
    color: Colors.background.primary,
  },

  disabledCheckoutButton: {
    backgroundColor: Colors.background.tertiary,
    opacity: 0.5,
    shadowOpacity: 0,
    elevation: 0,
  },

  // Clickable Travel Indicator Styles
  clickableIndicator: {
    borderWidth: 2,
    borderColor: Colors.primary,
    backgroundColor: Colors.background.secondary,
    shadowColor: Colors.primary,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.3,
    shadowRadius: 4,
    elevation: 3,
  },

  bookedIndicator: {
    backgroundColor: Colors.success,
    borderColor: Colors.success,
    shadowColor: Colors.success,
  },

  bookedIcon: {
    color: Colors.background.primary,
    fontWeight: '700',
  },

  bookedTime: {
    color: Colors.background.primary,
    fontWeight: '700',
  },

  // Travel Indicator Container
  travelIndicatorContainer: {
    alignItems: 'center',
  },

  bookRideText: {
    fontSize: 9,
    color: Colors.primary,
    fontWeight: '600',
    textAlign: 'center',
    marginTop: 4,
    letterSpacing: 0.3,
  },

  // Debug Panel Styles
  debugToggleButton: {
    position: 'absolute',
    bottom: 20,
    right: 20,
    backgroundColor: Colors.warning,
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 4,
    elevation: 5,
    zIndex: 1000,
  },
  debugToggleText: {
    color: Colors.background.primary,
    fontSize: 12,
    fontWeight: '600',
  },
  debugPanel: {
    position: 'absolute',
    bottom: 80,
    left: 20,
    right: 20,
    backgroundColor: Colors.background.secondary,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: Colors.glassBorder,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 8,
    elevation: 10,
    zIndex: 999,
    maxHeight: height * 0.6,
  },
  debugHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: Colors.glassBorder,
  },
  debugTitle: {
    fontSize: 16,
    fontWeight: '700',
    color: Colors.text.primary,
  },
  debugCloseButton: {
    width: 30,
    height: 30,
    borderRadius: 15,
    backgroundColor: Colors.error,
    justifyContent: 'center',
    alignItems: 'center',
  },
  debugCloseText: {
    color: Colors.background.primary,
    fontSize: 18,
    fontWeight: '700',
  },
  debugControls: {
    flexDirection: 'row',
    padding: 16,
    gap: 8,
  },
  debugButton: {
    flex: 1,
    backgroundColor: Colors.background.tertiary,
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderRadius: 8,
    alignItems: 'center',
    borderWidth: 1,
    borderColor: Colors.glassBorder,
  },
  debugButtonActive: {
    backgroundColor: Colors.success,
    borderColor: Colors.success,
  },
  debugButtonText: {
    color: Colors.text.primary,
    fontSize: 12,
    fontWeight: '600',
  },
  debugLogContainer: {
    maxHeight: 200,
    padding: 16,
  },
  debugLogText: {
    fontSize: 11,
    color: Colors.text.secondary,
    fontFamily: Platform.OS === 'ios' ? 'Menlo' : 'monospace',
    lineHeight: 16,
  },
});

export default ItineraryResultsPage;

